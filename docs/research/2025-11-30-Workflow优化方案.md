# SCM Workflow 优化方案

## 1. 背景

### 1.1 调研范围
- Spring AI Alibaba 官方Graph实现 (`spring-ai-alibaba-graph-core`)
- 官方示例代码 (`spring-ai-alibaba-graph-example`)
- SCM当前Workflow实现 (`scm-ai/workflow/`)

### 1.2 现状分析

| 指标 | 官方示例 | SCM实现 |
|------|---------|---------|
| StateGraph配置 | ~30行 | ~200行 |
| Node实现 | ~20行/节点 | ~100-300行/节点 |
| Engine核心 | 无（框架提供） | 987行 |
| 总代码量 | ~100行 | ~3000行+ |

## 2. 官方 vs SCM 架构对比

### 2.1 官方设计模式（声明式、简洁）

```java
// 官方StateGraph配置示例 (~30行)
StateGraph stateGraph = new StateGraph(keyStrategyFactory)
    .addNode("expander", node_async(new ExpanderNode(chatClientBuilder)))
    .addNode("human_feedback", node_async(new HumanFeedbackNode()))
    .addEdge(StateGraph.START, "expander")
    .addConditionalEdges("human_feedback", edge_async(dispatcher), mapping);

// 官方Node实现 (~20行)
public class HumanFeedbackNode implements NodeAction {
    @Override
    public Map<String, Object> apply(OverAllState state) {
        boolean feedback = (boolean) state.humanFeedback().data().getOrDefault("feed_back", true);
        return Map.of("human_next_node", feedback ? "translate" : StateGraph.END);
    }
}
```

**特点**：
- 节点只关心业务逻辑
- 状态管理通过KeyStrategyFactory统一处理
- 无数据库、租户、SSE等基础设施代码

### 2.2 SCM设计模式（命令式、复杂）

**WorkflowEngine.java (987行)**：
- 混合业务逻辑和基础设施代码
- 手动管理数据源切换
- 手动管理运行时记录
- 手动处理SSE事件
- 手动处理中断/恢复逻辑

**关键差异原因**：
| 需求 | 官方示例 | SCM业务需求 |
|------|---------|------------|
| 多租户 | 不支持 | 必须支持 |
| 执行记录持久化 | 可选（MemorySaver） | 必须（用于调试审计） |
| SSE流式输出 | 不支持 | 必须（前端实时显示） |
| 人机交互 | 简单示例 | 完整功能 |
| 子工作流 | 不支持 | 必须支持 |

## 3. SCM复杂性分析

### 3.1 必要的复杂性（不能删除）
1. **多租户数据源切换** - DataSourceHelper.use(tenantCode)
2. **执行记录持久化** - RuntimeService调用
3. **SSE事件发送** - streamHandler.sendXxx()
4. **人机交互中断/恢复** - InterruptedFlow机制
5. **子工作流支持** - parentRuntimeUuid传递

### 3.2 可优化的复杂性
1. **WorkflowEngine太大** - 987行违反单一职责
2. **重复的数据源切换** - 每个方法都有DataSourceHelper.use
3. **AI_CHAT vs WORKFLOW_TEST双路径** - 大量if-else判断
4. **手动构建StateGraph** - buildCompileNode、buildStateGraph复杂

## 4. 优化方案

### 4.1 方案A：拆分WorkflowEngine（推荐）

将987行的WorkflowEngine拆分为5个类：

#### 4.1.1 WorkflowGraphBuilder (~200行)
```java
/**
 * 负责构建StateGraph
 */
public class WorkflowGraphBuilder {
    // 从WorkflowEngine提取以下方法：
    // - buildCompileNode()
    // - buildStateGraph()
    // - addNodeToStateGraph()
    // - addEdgeToStateGraph()
    // - getOrCreateGraphCompileNode()

    public CompiledGraph build(List<AiWorkflowNodeVo> nodes,
                               List<AiWorkflowEdgeEntity> edges,
                               List<AiWorkflowComponentEntity> components) {
        // 构建逻辑
    }
}
```

#### 4.1.2 WorkflowExecutionContext (~150行)
```java
/**
 * 管理执行上下文
 */
public class WorkflowExecutionContext {
    private WfState wfState;
    private Long userId;
    private String tenantCode;
    private WorkflowCallSource callSource;
    private Long runtimeId;

    // 上下文初始化和管理方法
}
```

#### 4.1.3 WorkflowRuntimePersistence (~150行)
```java
/**
 * 统一双领域的持久化逻辑
 */
public class WorkflowRuntimePersistence {

    public RuntimeVo createRuntime(WorkflowExecutionContext ctx, Long workflowId) {
        if (ctx.getCallSource() == WorkflowCallSource.AI_CHAT) {
            return conversationRuntimeService.create(ctx.getUserId(), workflowId);
        } else {
            return workflowRuntimeService.create(ctx.getUserId(), workflowId);
        }
    }

    public void updateInput(WorkflowExecutionContext ctx, WfState state) {
        // 统一处理
    }

    public void updateOutput(WorkflowExecutionContext ctx, WfState state) {
        // 统一处理
    }
}
```

#### 4.1.4 WorkflowEventPublisher (~100行)
```java
/**
 * 封装SSE事件发送
 */
public class WorkflowEventPublisher {
    private final WorkflowStreamHandler streamHandler;

    public void publishStart(RuntimeVo runtime) {
        streamHandler.sendStart(JSONObject.toJSONString(runtime));
    }

    public void publishNodeRun(String nodeUuid, Object nodeVo) {
        streamHandler.sendNodeRun(nodeUuid, JSONObject.toJSONString(nodeVo));
    }

    public void publishNodeInput(String nodeUuid, NodeIOData input) {
        streamHandler.sendNodeInput(nodeUuid, JSONObject.toJSONString(input));
    }

    // 其他事件发送方法...
}
```

#### 4.1.5 WorkflowEngine (简化为~300行)
```java
/**
 * 编排以上组件，保持对外接口不变
 */
public class WorkflowEngine {
    private final WorkflowGraphBuilder graphBuilder;
    private final WorkflowRuntimePersistence persistence;
    private final WorkflowEventPublisher eventPublisher;

    public void run(Long userId, List<JSONObject> userInputs,
                    String tenantCode, String parentConversationId) {
        // 简化后的主流程
    }

    public void resume(String userInput) {
        // 简化后的恢复流程
    }
}
```

### 4.2 方案B：使用AOP简化数据源切换

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface TenantDataSource {
}

@Aspect
@Component
public class TenantDataSourceAspect {
    @Around("@annotation(TenantDataSource)")
    public Object switchDataSource(ProceedingJoinPoint joinPoint) throws Throwable {
        // 从上下文获取tenantCode并切换数据源
        String tenantCode = TenantContextHolder.get();
        DataSourceHelper.use(tenantCode);
        try {
            return joinPoint.proceed();
        } finally {
            DataSourceHelper.close();
        }
    }
}
```

### 4.3 方案C：统一双领域服务接口

```java
/**
 * 统一的Runtime服务接口
 */
public interface IWorkflowRuntimeService {
    RuntimeVo create(Long userId, Long workflowId);
    RuntimeVo createWithConversationId(Long userId, Long workflowId, String conversationId);
    void updateInput(Long runtimeId, WfState state);
    void updateOutput(Long runtimeId, WfState state);
    void updateStatus(Long runtimeId, Integer status, String errorMsg);
    RuntimeEntity getByUuid(String uuid);
}

/**
 * AI Chat场景实现
 */
@Service("aiChatRuntimeService")
public class AiChatRuntimeServiceImpl implements IWorkflowRuntimeService {
    @Autowired
    private AiConversationRuntimeService conversationRuntimeService;
    // 委托给conversationRuntimeService
}

/**
 * Workflow测试场景实现
 */
@Service("workflowTestRuntimeService")
public class WorkflowTestRuntimeServiceImpl implements IWorkflowRuntimeService {
    @Autowired
    private AiWorkflowRuntimeService workflowRuntimeService;
    // 委托给workflowRuntimeService
}
```

## 5. 不需要改动的部分

### 5.1 表结构保持不变
- `ai_conversation_content` - 行级存储满足前端消息列表需求
- `ai_workflow_conversation_content` - 同上
- `ai_conversation_runtime` / `ai_workflow_runtime` - 执行记录

### 5.2 Node实现保持不变
- `AbstractWfNode` 设计合理
- 各具体Node实现满足业务需求

### 5.3 WfState保持不变
- 虽然与官方OverAllState不同
- 但满足SCM的多租户、子工作流等业务需求

### 5.4 SSE流式输出保持不变
- 官方没有这个功能
- SCM自己实现是必要的

## 6. 实施计划

### 6.1 优先级

| 优先级 | 方案 | 预期收益 | 工作量 |
|-------|------|---------|-------|
| 高 | A: 拆分WorkflowEngine | 代码可维护性大幅提升 | 3-5天 |
| 中 | C: 统一双领域服务 | 减少重复代码 | 2-3天 |
| 低 | B: AOP数据源切换 | 减少样板代码 | 1-2天 |

### 6.2 分阶段实施

**第一阶段（高优先级）**：
1. 创建WorkflowGraphBuilder，提取图构建逻辑
2. 创建WorkflowRuntimePersistence，统一持久化逻辑
3. 创建WorkflowEventPublisher，封装事件发送
4. 简化WorkflowEngine

**第二阶段（中优先级）**：
1. 定义IWorkflowRuntimeService接口
2. 实现两个场景的适配器
3. 修改WorkflowEngine使用统一接口

**第三阶段（低优先级）**：
1. 创建@TenantDataSource注解
2. 实现AOP切面
3. 替换手动的DataSourceHelper调用

## 7. 预期效果

| 指标 | 优化前 | 优化后 |
|------|-------|-------|
| WorkflowEngine行数 | 987行 | ~300行 |
| 代码重复率 | 高 | 低 |
| 可测试性 | 差 | 好 |
| 可维护性 | 差 | 好 |
| 双领域代码重复 | ~200行 | ~20行 |

## 8. 风险评估

### 8.1 低风险
- 拆分为多个类是纯重构，不改变功能
- 可以增量实施，每个类独立测试

### 8.2 需要注意
- 保持对外接口不变（run、resume方法签名）
- 确保多租户场景正确切换数据源
- SSE事件发送时机保持一致

## 9. 结论

SCM的Workflow实现之所以比官方复杂，是因为有真实的业务需求（多租户、持久化、SSE、人机交互等）。官方示例只是演示框架用法，不能直接照搬。

**优化方向是**：
1. 拆分大类，分离关注点
2. 减少重复代码
3. 保持所有现有功能

**不建议**：
- 不建议用官方的MemorySaver替换当前持久化（存储格式不兼容）
- 不建议大规模重构Node实现（当前设计合理）
- 不建议删除多租户支持（业务必须）

---

**文档版本**: v1.0
**创建日期**: 2025-11-30
**作者**: Claude Code
