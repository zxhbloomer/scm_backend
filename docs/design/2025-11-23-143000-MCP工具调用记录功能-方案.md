# MCP工具调用记录功能 - 技术方案

## 1. 需求背景

### 1.1 业务需求
在AI工作流执行过程中,LLM通过Spring AI的Function Calling机制自主调用MCP工具。当前系统只保存LLM的最终输出,无法追溯执行过程中调用了哪些MCP工具。

**核心诉求**: "我只想知道调用了哪个mcp" - 需要为MCP工具调用建立留痕机制。

### 1.2 技术挑战
- MCP工具调用由LLM自主决定,不在代码显式调用链中
- 工具执行发生在Spring AI的异步回调中
- 需要在不破坏现有架构的前提下增加记录功能

## 2. KISS原则7问评估

### 2.1 这是个真问题还是臆想出来的?
**真问题**。用户在执行详情对话框中需要查看MCP调用历史,这是审计和调试的实际需求。

### 2.2 有更简单的方法吗?
当前方案已是最简方案:
- 利用现有的 `ToolContext` 传递机制
- 复用现有的 `NodeIOData` 数据结构
- 不需要新增数据库表或字段

### 2.3 会破坏什么吗?
**零破坏性**:
- 不修改数据库表结构
- 不改变现有API接口
- 只在 `output_data` JSON字段中增加新的key
- 向后兼容: 旧数据没有 `mcp_tool_calls` 不影响现有功能

### 2.4 当前项目真的需要这个功能吗?
**需要**。工作流执行详情是系统核心功能,MCP调用记录是完善审计追踪的必要补充。

### 2.5 数据结构是否合理?
**合理**。使用List保存调用序列,每次调用记录最小必要信息(5个字段)。

### 2.6 复杂度是否最小化?
**最小化**。只需修改2个文件,不引入新的依赖和抽象层。

### 2.7 实用性验证
**实用**。用户可在执行详情对话框直接看到MCP调用历史,便于问题排查。

## 3. 技术方案设计

### 3.1 完整调用链分析

```
WorkflowEngine.java (执行工作流)
    ↓
WorkflowUtil.streamingInvokeLLM() (调用LLM)
    ↓
AiChatBaseService.chatWithWorkflowMemoryStream()
    ↓
    设置 chatOption.setToolContext(Map.of(
        "tenantCode", wfState.getTenantCode(),
        "staffId", wfState.getUserId(),
        "nodeState", nodeState  ← 【修改点1: 新增】
    ))
    ↓
Spring AI Function Calling 决定调用哪个MCP工具
    ↓
McpToolConfig.createToolCallback() 中的 BiFunction
    ↓
    【修改点2: 新增记录逻辑】
    1. 从 ToolContext 提取 nodeState
    2. 记录工具调用信息到 nodeState.outputs
    3. 执行实际的MCP工具方法
    ↓
WorkflowEngine 的输出回调
    ↓
workflowRuntimeNodeService.updateOutput()
    ↓
保存到 ai_workflow_runtime_node.output_data
```

### 3.2 数据结构设计

#### 3.2.1 output_data JSON结构
```json
{
  "output": {
    "title": "输出",
    "type": 1,
    "value": "这是LLM的最终输出内容..."
  },
  "mcp_tool_calls": [
    {
      "toolName": "WarehouseMcpTools.queryWarehouses",
      "description": "查询仓库信息，支持按编码、名称、地理位置、状态等多种条件查询仓库列表",
      "callTime": "2025-11-23T14:30:25",
      "success": true,
      "error": null
    },
    {
      "toolName": "WarehouseMcpTools.getWarehouseDetail",
      "description": "根据仓库ID获取仓库详细信息",
      "callTime": "2025-11-23T14:30:28",
      "success": false,
      "error": "仓库不存在: ID=999"
    }
  ]
}
```

#### 3.2.2 字段说明
| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| toolName | String | 是 | 完整工具名: `类名.方法名` |
| description | String | 是 | 来自 `@McpTool(description)` |
| callTime | String | 是 | ISO 8601格式: `yyyy-MM-dd'T'HH:mm:ss` |
| success | Boolean | 是 | 执行是否成功 |
| error | String | 否 | 失败时的错误信息,成功时为null |

### 3.3 实现方案

#### 3.3.1 WorkflowUtil.java 修改

**文件位置**: `scm-ai/src/main/java/com/xinyirun/scm/ai/workflow/WorkflowUtil.java`

**修改位置**: Line 182-185

**修改前**:
```java
// 设置 toolContext，传递租户编码和用户ID给 MCP 工具
chatOption.setToolContext(Map.of(
    "tenantCode", wfState.getTenantCode(),
    "staffId", wfState.getUserId()
));
```

**修改后**:
```java
// 设置 toolContext，传递租户编码、用户ID和节点状态给 MCP 工具
chatOption.setToolContext(Map.of(
    "tenantCode", wfState.getTenantCode(),
    "staffId", wfState.getUserId(),
    "nodeState", nodeState  // 传递节点状态用于记录MCP调用
));
```

#### 3.3.2 McpToolConfig.java 修改

**文件位置**: `scm-ai/src/main/java/com/xinyirun/scm/ai/config/mcp/McpToolConfig.java`

**修改位置**: Line 118-151 的 BiFunction 内部

**修改方案**:

```java
BiFunction<Map<String, Object>, ToolContext, String> toolFunction =
    (inputMap, toolContext) -> {
        // 1. 记录MCP工具调用开始
        String callStartTime = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        boolean callSuccess = false;
        String errorMessage = null;

        try {
            // 2. 原有逻辑: 提取 tenantCode 和 staffId
            String tenantCode = null;
            if (toolContext != null && toolContext.getContext().containsKey("tenantCode")) {
                tenantCode = (String) toolContext.getContext().get("tenantCode");
            }

            if (tenantCode == null) {
                tenantCode = DataSourceHelper.getCurrentDataSourceName();
            }

            if (tenantCode != null) {
                inputMap.put("tenantCode", tenantCode);
            }

            if (toolContext != null && toolContext.getContext().containsKey("staffId")) {
                Object staffId = toolContext.getContext().get("staffId");
                if (staffId != null) {
                    inputMap.put("staffId", staffId);
                }
            }

            // 3. 执行MCP工具
            Object[] args = extractParameters(inputMap, method);
            Object result = method.invoke(bean, args);
            callSuccess = true;
            return result != null ? result.toString() : "执行成功";

        } catch (Exception e) {
            callSuccess = false;
            errorMessage = e.getMessage();
            throw new RuntimeException("MCP工具执行失败: " + e.getMessage(), e);

        } finally {
            // 4. 记录MCP工具调用到 nodeState (无论成功或失败都记录)
            if (toolContext != null && toolContext.getContext().containsKey("nodeState")) {
                WfNodeState nodeState = (WfNodeState) toolContext.getContext().get("nodeState");

                // 创建MCP调用记录
                Map<String, Object> mcpCallRecord = new HashMap<>();
                mcpCallRecord.put("toolName", toolName);
                mcpCallRecord.put("description", description);
                mcpCallRecord.put("callTime", callStartTime);
                mcpCallRecord.put("success", callSuccess);
                mcpCallRecord.put("error", errorMessage);

                // 添加到节点输出
                NodeIOData mcpCallData = new NodeIOData();
                mcpCallData.setName("mcp_tool_call_" + System.currentTimeMillis()); // 唯一key

                NodeIODataOptionsContent content = new NodeIODataOptionsContent();
                content.setTitle("MCP工具调用");
                content.setValue(mcpCallRecord);
                mcpCallData.setContent(content);

                nodeState.getOutputs().add(mcpCallData);
            }
        }
    };
```

**关键点说明**:
1. 使用 `finally` 块确保无论成功失败都记录调用
2. 使用 `System.currentTimeMillis()` 生成唯一的key避免覆盖
3. 使用 `NodeIODataOptionsContent` 存储Map数据
4. 直接添加到 `nodeState.getOutputs()`,利用现有的回调机制保存

#### 3.3.3 前端显示优化 (可选)

**文件位置**: `scm_frontend/src/components/70_ai/components/common/ExecutionDetailDialog.vue`

**修改位置**: Line 70-76 输出数据部分

**可选增强**: 单独显示MCP调用历史

```vue
<!-- 输出数据 -->
<div v-if="node.outputData || node.output_data" class="node-data-section">
  <div class="data-label">输出数据:</div>
  <el-card shadow="never" class="data-card">
    <pre class="json-content">{{ formatJSON(node.outputData || node.output_data) }}</pre>
  </el-card>
</div>

<!-- MCP工具调用历史 (新增 - 可选) -->
<div v-if="getMcpToolCalls(node)" class="node-data-section">
  <div class="data-label">MCP工具调用:</div>
  <el-timeline>
    <el-timeline-item
      v-for="(call, idx) in getMcpToolCalls(node)"
      :key="idx"
      :type="call.success ? 'success' : 'danger'"
      :icon="call.success ? 'el-icon-circle-check' : 'el-icon-circle-close'"
    >
      <div class="mcp-call-item">
        <div><strong>{{ call.toolName }}</strong></div>
        <div class="mcp-description">{{ call.description }}</div>
        <div class="mcp-time">{{ call.callTime }}</div>
        <el-alert v-if="!call.success" :title="call.error" type="error" :closable="false" />
      </div>
    </el-timeline-item>
  </el-timeline>
</div>
```

**新增方法**:
```javascript
methods: {
  getMcpToolCalls(node) {
    try {
      const outputData = node.outputData || node.output_data;
      if (!outputData) return null;

      const data = typeof outputData === 'string' ? JSON.parse(outputData) : outputData;

      // 提取所有以 mcp_tool_call_ 开头的字段
      const mcpCalls = [];
      for (const key in data) {
        if (key.startsWith('mcp_tool_call_')) {
          mcpCalls.push(data[key].value);
        }
      }

      return mcpCalls.length > 0 ? mcpCalls : null;
    } catch (e) {
      return null;
    }
  }
}
```

## 4. 风险评估

### 4.1 技术风险
| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| ToolContext传递失败 | 低 | 中 | finally块中检查nodeState是否存在 |
| JSON序列化失败 | 低 | 低 | NodeIOData已有成熟的序列化机制 |
| 性能影响 | 低 | 低 | 只记录5个字段,开销极小 |

### 4.2 向后兼容性
- **完全兼容**: 旧数据没有 `mcp_tool_calls` 字段不影响现有功能
- **前端兼容**: 可选显示MCP调用历史,不影响现有UI

### 4.3 数据一致性
- **保证一致性**: 使用 `finally` 块确保调用必定被记录
- **时序保证**: 使用 `System.currentTimeMillis()` 确保key唯一性

## 5. 实施计划

### 5.1 开发任务
1. 修改 `WorkflowUtil.java` - 传递 nodeState (1行代码)
2. 修改 `McpToolConfig.java` - 添加记录逻辑 (约30行代码)
3. (可选) 修改 `ExecutionDetailDialog.vue` - 优化显示 (约40行代码)

### 5.2 测试验证
1. 单元测试: 验证MCP调用记录的数据结构
2. 集成测试: 验证数据保存到数据库
3. 端到端测试: 验证前端显示正确

### 5.3 回滚方案
- 代码修改量小,可直接回滚Git提交
- 不涉及数据库结构变更,零风险

## 6. 代码简洁性评估

### 6.1 行数对比
- 实际修改: 约31行代码 (WorkflowUtil 1行 + McpToolConfig 30行)
- 可选增强: 约40行代码 (前端显示优化)
- **总计**: 核心功能仅31行,远低于100行阈值

### 6.2 复用性
- 复用 `ToolContext` 传递机制
- 复用 `NodeIOData` 数据结构
- 复用 `WorkflowEngine` 回调机制
- 复用 `NodeIODataOptionsContent` 序列化能力

### 6.3 职责单一性
- `WorkflowUtil`: 只负责传递 nodeState
- `McpToolConfig`: 只负责记录调用
- `WorkflowEngine`: 保持不变,利用现有回调
- 每个组件职责清晰,符合单一职责原则

## 7. 总结

### 7.1 方案优势
1. **最小改动**: 只需修改2个文件,31行代码
2. **零破坏性**: 不改数据库,不改API,向后兼容
3. **高内聚**: 记录逻辑封装在MCP工具回调中
4. **易维护**: 代码简洁,逻辑清晰

### 7.2 Linus式评价
> "这是个真问题的简单解决方案。没有特殊情况,没有复杂抽象,就是在工具执行时记录一下,然后利用现有机制保存。简洁实用。"

### 7.3 实施建议
1. 先实现核心功能 (后端31行代码)
2. 测试验证数据保存正确
3. 再考虑前端显示优化 (可选)

---

**方案作者**: zzxxhh
**创建时间**: 2025-11-23 14:30:00
**版本**: v1.0
