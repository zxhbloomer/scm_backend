# AI Chat 模块优化方案设计文档

## 1. 变更概述

### 1.1 变更目标
优化 SCM AI 模块的 AI Chat 实现，简化 AiConversationController，删除不必要的代码，统一走工作流路由模式。

### 1.2 核心原则
- **保留 ChatResponseVo 结构** - 前端已适配，字段都是业务必需
- **删除 Feature Toggle 双模式** - 统一走工作流路由模式
- **职责分离** - Controller 只负责接收请求和返回响应，转换逻辑移到 Service 层

### 1.3 变更范围

| 文件 | 变更类型 | 说明 |
|------|----------|------|
| `AiConversationController.java` | 大幅简化 | 从1112行简化到~600行 |
| `WorkflowRoutingService.java` | 增强 | 新增 resumeWorkflow() 方法 |
| `WorkflowEventAdapter.java` | 新增 | 事件转换逻辑抽取 |
| `application.yml` | 删除配置 | 删除 scm.ai.workflow.enabled |

---

## 2. 现状分析

### 2.1 Spring AI Alibaba 官方实现

通过深入研究 `D:\2025_project\20_project_in_github\99_tools\spring-ai-alibaba` 源码：

**GraphStreamController.java** (官方示例)：
```java
@GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<ServerSentEvent<String>> stream(...) {
    Flux<NodeOutput> resultStream = compiledGraph.fluxStream(initialState, runnableConfig);
    return graphProcess.processStream(resultStream);
}
```

**GraphProcess.java** (事件转换)：
```java
public void processStream(Flux<NodeOutput> nodeOutputFlux, Sinks.Many<ServerSentEvent<String>> sink) {
    nodeOutputFlux.doOnNext(output -> {
        String content;
        if (output instanceof StreamingOutput streamingOutput) {
            content = JSON.toJSONString(Map.of("type", "streaming", "node", output.node(), "chunk", streamingOutput.chunk()));
        } else {
            JSONObject nodeOutput = new JSONObject();
            nodeOutput.put("type", "node_output");
            nodeOutput.put("node", output.node());
            nodeOutput.put("data", output.state().data());
            content = JSON.toJSONString(nodeOutput);
        }
        sink.tryEmitNext(ServerSentEvent.builder(content).build());
    }).subscribe();
}
```

**关键发现**：
1. 官方也需要事件转换层（NodeOutput → JSON）
2. 返回格式是 `Flux<ServerSentEvent<String>>` + JSON字符串
3. JSON 包含：type, node, data/chunk, timestamp

### 2.2 SCM 现有实现问题

**AiConversationController.java (1112行)**：

| 代码段 | 行号 | 行数 | 问题 |
|--------|------|------|------|
| Feature Toggle | 117-118 | 2 | 双模式维护负担 |
| chatStreamWithoutWorkflow() | 727-836 | 109 | 冗余代码，应删除 |
| convertWorkflowEventToResponse() | 560-681 | 121 | 应移到 Service 层 |
| extractRuntimeUuid/WorkflowUuid | 686-713 | 27 | 应移到 Service 层 |
| isInputContinuation() | 539-555 | 16 | 应移到 Service 层 |
| chatStream() 业务逻辑 | 315-529 | 214 | 过于复杂，应简化 |

**问题汇总**：
1. Controller 承担了太多职责（事件转换、状态管理、数据库操作）
2. 同样的转换逻辑在多处重复（chatStream、executeWorkflowCommand）
3. Feature Toggle 导致代码路径分叉

### 2.3 ChatResponseVo 必要性分析

**结论：保留 ChatResponseVo 结构**

原因：
1. 前端已适配此结构，修改会引入不必要的风险
2. 字段都是业务必需的：

| 字段 | 用途 | 必要性 |
|------|------|--------|
| results.content | 核心文本内容 | 必需 |
| isError | 前端快速判断错误 | 必需 |
| isWaitingInput | 工作流等待用户输入 | 必需 |
| isComplete | 工作流完成状态 | 必需 |
| runtimeUuid | 查询执行详情 | 必需 |
| workflowUuid | 恢复工作流 | 必需 |
| messageId | 消息删除操作 | 必需 |
| mcpToolResults | MCP工具结果（页面跳转） | 必需 |

---

## 3. 详细变更方案

### 3.1 Phase 1: 删除 Feature Toggle 和旧代码

**3.1.1 删除配置**

`application.yml` (删除)：
```yaml
scm:
  ai:
    workflow:
      enabled: false  # 删除此配置
```

**3.1.2 删除 AiConversationController 中的旧代码**

删除以下代码段：
- 第117-118行：`@Value` 注入 `enableWorkflowRouting`
- 第320-324行：`if (!enableWorkflowRouting)` 分支
- 第727-836行：整个 `chatStreamWithoutWorkflow()` 方法 (109行)

### 3.2 Phase 2: 创建 WorkflowEventAdapter

**新建文件**：`scm-ai/src/main/java/com/xinyirun/scm/ai/core/adapter/WorkflowEventAdapter.java`

```java
package com.xinyirun.scm.ai.core.adapter;

import com.alibaba.fastjson2.JSONObject;
import com.xinyirun.scm.ai.bean.vo.response.ChatResponseVo;
import com.xinyirun.scm.ai.bean.vo.workflow.WorkflowEventVo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 工作流事件适配器
 *
 * 负责将 WorkflowEventVo 转换为 ChatResponseVo
 *
 * @author SCM-AI
 * @since 2025-11-30
 */
@Slf4j
@Component
public class WorkflowEventAdapter {

    /**
     * 转换 WorkflowEventVo 为 ChatResponseVo
     */
    public ChatResponseVo convert(WorkflowEventVo event) {
        // 从 AiConversationController.convertWorkflowEventToResponse() 迁移的逻辑
        // ... (完整实现见下方)
    }

    /**
     * 从事件中提取 runtimeUuid
     */
    public String extractRuntimeUuid(WorkflowEventVo event) {
        // 从 AiConversationController.extractRuntimeUuidFromEvent() 迁移
    }

    /**
     * 从事件中提取 workflowUuid
     */
    public String extractWorkflowUuid(WorkflowEventVo event) {
        // 从 AiConversationController.extractWorkflowUuidFromEvent() 迁移
    }
}
```

### 3.3 Phase 3: 增强 WorkflowRoutingService

**新增方法**：`resumeWorkflow()`

```java
/**
 * 恢复暂停的工作流执行
 *
 * @param runtimeUuid 运行时UUID
 * @param workflowUuid 工作流UUID
 * @param userInput 用户输入
 * @param tenantCode 租户编码
 * @param conversationId 会话ID
 * @return Flux<ChatResponseVo> 流式响应
 */
public Flux<ChatResponseVo> resumeWorkflow(
        String runtimeUuid,
        String workflowUuid,
        String userInput,
        String tenantCode,
        String conversationId) {

    return workflowStarter.resumeFlowAsFlux(
        runtimeUuid,
        workflowUuid,
        userInput,
        tenantCode,
        WorkflowCallSource.AI_CHAT,
        conversationId
    ).map(event -> workflowEventAdapter.convert(event));
}

/**
 * 判断用户输入是继续当前工作流还是新意图
 *
 * 从 AiConversationController.isInputContinuation() 迁移
 */
public boolean isInputContinuation(String userInput, String currentWorkflowUuid, Long userId) {
    // 策略1: 明确的继续关键词
    if (userInput.matches("(?i)继续|continue|是|好|确认|ok")) {
        return true;
    }
    // 策略2: 短输入(<20字符)
    if (userInput.length() <= 20) {
        return true;
    }
    // 策略3: 路由判断
    String newWorkflowUuid = route(userInput, userId, null);
    return newWorkflowUuid == null || newWorkflowUuid.equals(currentWorkflowUuid);
}
```

### 3.4 Phase 4: 简化 AiConversationController.chatStream()

**目标**：从 ~215 行简化到 ~80 行

**简化后的代码结构**：

```java
@PostMapping(value = "/chat/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<ChatResponseVo> chatStream(@Validated @RequestBody AIChatRequestVo request) {
    // 1. 提取参数
    String conversationId = request.getConversationId();
    Long operatorId = SecurityUtil.getStaff_id();
    String tenantId = conversationId.split("::", 2)[0];
    request.setTenantId(tenantId);
    Map<String, Object> pageContext = request.getPageContext();
    String userPrompt = request.getPrompt();
    StringBuilder aiResponseBuilder = new StringBuilder();

    // 2. 查询对话状态 → 决定执行路径 → 返回响应
    return Mono.fromCallable(() -> {
                DataSourceHelper.use(tenantId);
                return aiConversationService.getConversation(conversationId);
            })
            .flatMapMany(conversation -> {
                String workflowState = conversation.getWorkflowState();
                if (workflowState == null) {
                    workflowState = WorkflowStateConstant.STATE_IDLE;
                }

                if (WorkflowStateConstant.STATE_WORKFLOW_WAITING_INPUT.equals(workflowState)) {
                    boolean isContinuation = workflowRoutingService.isInputContinuation(
                        userPrompt, conversation.getCurrentWorkflowUuid(), operatorId);

                    if (isContinuation) {
                        // 继续当前工作流
                        return workflowRoutingService.resumeWorkflow(
                            conversation.getCurrentRuntimeUuid(),
                            conversation.getCurrentWorkflowUuid(),
                            userPrompt,
                            tenantId,
                            conversationId
                        );
                    } else {
                        // 新意图,清理旧状态
                        aiConversationService.updateWorkflowState(
                            conversationId, WorkflowStateConstant.STATE_IDLE, null, null);
                    }
                }

                // 新请求或新意图 - 路由并执行
                return workflowRoutingService.routeAndExecute(
                    userPrompt, operatorId, tenantId, conversationId, pageContext, null);
            })
            // 3. 状态更新和内容保存
            .map(response -> handleResponse(response, conversationId, userPrompt, operatorId, aiResponseBuilder))
            // 4. 错误处理
            .timeout(Duration.ofMinutes(30))
            .onErrorResume(e -> handleError(e, conversationId))
            .doFinally(signalType -> DataSourceHelper.close());
}

// 抽取的辅助方法
private ChatResponseVo handleResponse(ChatResponseVo response, String conversationId,
        String userPrompt, Long operatorId, StringBuilder aiResponseBuilder) {
    // 累积内容、更新状态、保存对话 的逻辑
    // ...
}

private Flux<ChatResponseVo> handleError(Throwable e, String conversationId) {
    // 错误处理逻辑
    // ...
}
```

---

## 4. 调用链路图

### 4.1 优化前

```
AiConversationController.chatStream()
├── if (!enableWorkflowRouting) → chatStreamWithoutWorkflow() [109行,删除]
└── if (enableWorkflowRouting)
    ├── STATE_WORKFLOW_WAITING_INPUT
    │   ├── isInputContinuation() [16行,移动]
    │   ├── workflowStarter.resumeFlowAsFlux() → Flux<WorkflowEventVo>
    │   └── convertWorkflowEventToResponse() [121行,移动]
    └── STATE_IDLE
        └── workflowRoutingService.routeAndExecute() → Flux<ChatResponseVo>
```

### 4.2 优化后

```
AiConversationController.chatStream()
├── STATE_WORKFLOW_WAITING_INPUT
│   ├── workflowRoutingService.isInputContinuation()
│   └── workflowRoutingService.resumeWorkflow() → Flux<ChatResponseVo>
└── STATE_IDLE
    └── workflowRoutingService.routeAndExecute() → Flux<ChatResponseVo>

WorkflowRoutingService
├── isInputContinuation() [从Controller迁移]
├── resumeWorkflow() [新增]
│   ├── workflowStarter.resumeFlowAsFlux() → Flux<WorkflowEventVo>
│   └── workflowEventAdapter.convert()
└── routeAndExecute() [现有]

WorkflowEventAdapter [新增]
├── convert(WorkflowEventVo) → ChatResponseVo
├── extractRuntimeUuid()
└── extractWorkflowUuid()
```

---

## 5. KISS 原则检查

### 5.1 七个问题检验

| 问题 | 回答 |
|------|------|
| 1. 这是个真问题还是臆想出来的？ | **真问题**。1112行的Controller明显过于臃肿，有109行冗余代码，职责混乱。 |
| 2. 有更简单的方法吗？ | **没有**。只是简单地删除代码和移动职责，是最简单的方案。 |
| 3. 会破坏什么吗？ | **不会**。保留ChatResponseVo结构，前端无需改动。 |
| 4. 当前项目真的需要这个功能吗？ | **需要**。Feature Toggle已经不再需要，应该删除以减少维护负担。 |
| 5. 复杂度是否与问题严重性匹配？ | **匹配**。删除~500行代码，新增~80行，净减少~420行。 |
| 6. 数据结构是否正确？ | **正确**。ChatResponseVo结构保持不变。 |
| 7. 是否有不必要的抽象？ | **没有**。WorkflowEventAdapter是必要的职责分离，不是过度抽象。 |

### 5.2 代码行数变化

| 文件 | 变更前 | 变更后 | 变化 |
|------|--------|--------|------|
| AiConversationController.java | 1112行 | ~600行 | -512行 |
| WorkflowRoutingService.java | 1449行 | ~1520行 | +71行 |
| WorkflowEventAdapter.java | 0行 | ~150行 | +150行 |
| **净变化** | - | - | **-291行** |

---

## 6. 风险评估

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| 删除 Feature Toggle 影响现有功能 | 低 | 中 | 用户已确认统一使用工作流模式 |
| 前端不兼容 | 极低 | 高 | 保留 ChatResponseVo 结构不变 |
| 转换逻辑移动后行为不一致 | 低 | 中 | 单元测试覆盖转换逻辑 |
| resumeWorkflow 新方法有bug | 中 | 中 | 完整测试恢复工作流场景 |

---

## 7. 测试计划

### 7.1 单元测试
- [ ] WorkflowEventAdapter.convert() 所有事件类型
- [ ] WorkflowRoutingService.isInputContinuation() 边界情况
- [ ] WorkflowRoutingService.resumeWorkflow() 正常和异常路径

### 7.2 集成测试
- [ ] 新对话 → 路由并执行工作流 → 完成
- [ ] 对话中断 → 恢复 → 继续执行
- [ ] 对话中断 → 新意图 → 路由新工作流
- [ ] MCP工具调用 → 页面跳转
- [ ] 错误场景 → 正确返回错误响应

### 7.3 回归测试
- [ ] 所有现有 AI Chat 功能正常
- [ ] 执行详情查询正常
- [ ] 消息删除功能正常

---

## 8. 实施步骤

| 步骤 | 操作 | 文件 |
|------|------|------|
| 1 | 创建 WorkflowEventAdapter | 新建 |
| 2 | 迁移 convertWorkflowEventToResponse() | Controller → Adapter |
| 3 | 迁移 extractRuntimeUuid/WorkflowUuid() | Controller → Adapter |
| 4 | 新增 WorkflowRoutingService.resumeWorkflow() | Service |
| 5 | 迁移 isInputContinuation() | Controller → Service |
| 6 | 简化 chatStream() | Controller |
| 7 | 删除 chatStreamWithoutWorkflow() | Controller |
| 8 | 删除 Feature Toggle 配置和相关代码 | Controller + yml |
| 9 | 编译验证 | - |
| 10 | 运行测试 | - |

---

## 9. 审批记录

| 角色 | 姓名 | 状态 | 日期 |
|------|------|------|------|
| 开发 | - | 等待审批 | 2025-11-30 |
| 评审 | - | 等待 | - |
