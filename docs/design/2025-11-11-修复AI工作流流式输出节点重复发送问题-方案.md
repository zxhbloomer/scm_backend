# 修复AI工作流流式输出节点重复发送问题 - 优化方案

## 问题描述

**现象**：用户输入"hello"后，前端显示：
```
{"title":"用户输入","type":1,"value":"hello"}
{"title":"用户输入","type":1,"value":"hello"}
{"title":"用户输入","type":1,"value":"hello"}
Hello! 😊 Nice to see you again!
What can I do for you today?
{"title":"","type":1,"value":"任务执行完成"}
```

**根因分析**：
1. 工作流执行时，所有节点的输出都通过SSE流式发送到前端
2. 当前结束节点（id=93）配置为固定输出"任务执行完成"
3. 前端显示了所有中间节点的JSON格式输出 + 最终固定文本

## 数据库现状

### 工作流节点结构（workflow_id=28 "test"）

| 节点ID | 组件名称 | 标题 | 当前配置 |
|--------|----------|------|----------|
| 91 | Start | 开始 | 起始节点 |
| 92 | Answer | 生成回答 | LLM节点，输出AI响应 |
| 93 | End | 结束 | `{"result": "任务执行完成"}` |

### 结束节点当前配置（Base64解码后）

```json
{
  "result": "任务执行完成"
}
```

## 优化方案

### 方案一：修改结束节点配置（推荐）

**目标**：让结束节点输出Answer节点的LLM响应

#### 实施步骤

1. **修改node_config**：
```json
{
  "result": "{{nodes.92.output.value}}"
}
```
或使用节点UUID：
```json
{
  "result": "{{nodes.4QxnnQ55nLqCCmDkNuhw6Pqfdcnk4rB6.output.value}}"
}
```

2. **执行SQL更新**：
```sql
UPDATE ai_workflow_node
SET node_config = JSON_OBJECT(
    'result', '{{nodes.92.output.value}}'
)
WHERE id = 93
  AND workflow_id = 28;
```

#### 优点
- ✅ 最小改动，只修改一个节点配置
- ✅ 符合工作流引擎的变量引用规范
- ✅ 不影响其他工作流
- ✅ 前端无需改动

#### 缺点
- ⚠️ 需要确认变量引用语法是否正确（需查看WorkflowEngine代码）

---

### 方案二：前端过滤中间输出（备选）

**目标**：前端只显示最终节点的输出

#### 实施位置
- 前端SSE消息处理逻辑
- 文件：`scm_frontend/src/views/70_aicomponents/chat/index.vue`（推测）

#### 实施步骤

1. **识别节点类型**：
```javascript
// SSE消息处理
onMessage(event) {
  const data = JSON.parse(event.data)

  // 只显示End节点的输出
  if (data.nodeType === 'End' || data.isFinal) {
    this.appendMessage(data.value)
  }
  // 忽略中间节点的输出
}
```

2. **或者只显示非JSON格式内容**：
```javascript
onMessage(event) {
  const data = JSON.parse(event.data)

  // 跳过包含title/type/value结构的中间输出
  if (data.title && data.type && data.value) {
    return // 忽略中间节点输出
  }

  // 显示最终文本响应
  this.appendMessage(data.value || data.result)
}
```

#### 优点
- ✅ 不修改后端逻辑
- ✅ 灵活控制前端显示逻辑

#### 缺点
- ❌ 治标不治本，问题根源在后端
- ❌ 所有使用该组件的地方都需要修改
- ❌ 浪费网络带宽传输中间数据

---

### 方案三：优化WorkflowEngine输出逻辑（彻底方案）

**目标**：引擎只发送最终节点输出，不发送中间节点

#### 实施位置
- 文件：`WorkflowEngine.java`
- 方法：`executeWithStreaming()` 或类似流式输出方法

#### 实施步骤

1. **分析当前代码**：
```java
// 当前逻辑（推测）
private void executeNode(NodeContext context) {
    // 执行节点
    String output = node.execute(context);

    // ❌ 问题：所有节点都发送SSE
    sseEmitter.send(output);
}
```

2. **修改为只发送End节点**：
```java
private void executeNode(NodeContext context) {
    // 执行节点
    String output = node.execute(context);

    // ✅ 只有End节点才发送到前端
    if (node.getType().equals("End")) {
        sseEmitter.send(output);
    }

    // 中间节点输出存入上下文供后续引用
    context.setNodeOutput(node.getId(), output);
}
```

#### 优点
- ✅ 彻底解决问题
- ✅ 优化网络传输
- ✅ 所有工作流都受益

#### 缺点
- ❌ 改动较大，需要理解WorkflowEngine完整逻辑
- ❌ 可能影响调试（中间节点输出不可见）
- ❌ 需要完整测试所有工作流

---

## 推荐实施路径

### 阶段1：快速修复（方案一）

**时间**：10分钟

1. 确认变量引用语法
2. 执行SQL更新结束节点配置
3. 测试"hello"输入，验证输出

**预期结果**：
```
Hello! 😊 Nice to see you again!
What can I do for you today?
```

### 阶段2：深度优化（方案三，可选）

**时间**：2-4小时

1. 分析WorkflowEngine代码
2. 修改流式输出逻辑
3. 完整测试所有工作流类型

---

## 实施验证

### 验证步骤

1. **修改配置后测试**：
```bash
# 前端输入
hello

# 预期后端日志
LLM路由决策: workflowUuid=null
Layer 3: 使用默认工作流, workflowUuid=73dbd4894ce544e5b044652f7edabd41
执行工作流: test (id=28)
节点92输出: Hello! 😊 Nice to see you again!\n\nWhat can I do for you today?
节点93输出: Hello! 😊 Nice to see you again!\n\nWhat can I do for you today?

# 预期前端显示（干净的文本）
Hello! 😊 Nice to see you again!

What can I do for you today?
```

2. **回归测试**：
- 测试其他工作流是否正常
- 测试复杂工作流（多个LLM节点）
- 测试错误处理流程

---

## 需要确认的技术细节

### 1. 变量引用语法

需要查看`WorkflowEngine.java`确认变量引用格式：
- 是否支持`{{nodes.节点ID.output.value}}`？
- 还是`{{node_92_output}}`？
- 或者其他格式？

### 2. 节点输出字段名

Answer节点的输出结构：
```json
{
  "value": "LLM响应文本",
  "type": 1,
  "title": "生成回答"
}
```

确认引用字段名：
- `{{nodes.92.output.value}}` - 只取文本
- `{{nodes.92.output}}` - 整个输出对象

---

## 后续改进建议

1. **统一工作流输出规范**：
   - 定义标准的节点输出格式
   - 明确哪些节点输出需要发送到前端

2. **增加节点配置验证**：
   - 保存工作流时检查变量引用是否有效
   - 提示用户引用了不存在的节点

3. **前端显示优化**：
   - 区分流式输出和最终结果
   - 显示"正在思考..."等加载状态

---

## 最终实施方案（已执行）

### 第一次修复：End 节点配置（部分解决）

**问题发现**：
通过分析日志和代码，发现 End 节点配置为固定文本：
- 当前配置：`{"result": "任务执行完成"}`
- 正确配置：`{"result": "${output}"}`（引用上游节点输出）

**实施的 SQL**：
```sql
-- 修改结束节点配置，使用模板变量引用上游节点输出
UPDATE ai_workflow_node
SET node_config = JSON_OBJECT('result', '${output}'),
    u_time = NOW()
WHERE id = 93
  AND workflow_id = 28
  AND is_deleted = 0;
```

**修复效果**：End 节点现在输出 Answer 节点的 LLM 响应，而不是固定文本。

---

### 第二次修复：Start 节点 OUTPUT 事件（真正解决）

**问题根因**：
从日志第 652-653 行发现，Start 节点的输出包含完整的 JSON 结构：
```json
output_data='{"output":{"title":"用户输入","type":1,"value":"hello"}}'
```

**数据流向分析**：
1. **Start 节点** (`StartNode.java:58`)
   - 调用 `WfNodeIODataUtil.changeInputsToOutputs(state.getInputs())`
   - 将 `var_user_input` 的完整 NodeIOData（包含 title、type、value）原样输出

2. **WorkflowEngine** (`WorkflowEngine.java:407-411`)
   - Start 节点不在跳过列表中（之前只跳过 Answer/SubWorkflow/End）
   - 发送 NODE_OUTPUT 事件：`JSONObject.toJSONString(output)`
   - 前端接收到：`{"title":"用户输入","type":1,"value":"hello"}`

**代码修复** (`WorkflowEngine.java:403-419`)：
```java
// 跳过以下节点的OUTPUT事件：
// - Start节点：用户输入不需要回显给前端（前端已经显示了用户输入）
// - Answer节点：已经通过NODE_CHUNK事件发送了流式内容
// - SubWorkflow节点：子工作流内部的Answer节点已经通过CHUNK事件发送了流式内容
// - End节点：结束节点的输出是最终结果，不需要单独发送OUTPUT事件
if (!"Start".equals(componentName)
    && !"Answer".equals(componentName)
    && !"SubWorkflow".equals(componentName)
    && !"End".equals(componentName)) {
    log.info("发送NODE_OUTPUT事件 - nodeUuid: {}, componentName: {}", nodeUuid, componentName);
    List<NodeIOData> nodeOutputs = nodeState.getOutputs();
    for (NodeIOData output : nodeOutputs) {
        streamHandler.sendNodeOutput(nodeUuid, JSONObject.toJSONString(output));
    }
} else {
    log.info("跳过NODE_OUTPUT事件 - componentName: {}（用户输入回显/流式输出/结束节点）", componentName);
}
```

**修复效果**：
- Start 节点的 OUTPUT 事件不再发送到前端
- 前端不再显示 JSON 格式的用户输入回显
- 用户只看到干净的 LLM 响应流式输出

---

### 关键代码逻辑汇总

**节点输出逻辑**：
- `StartNode.java:58` - Start 节点：`WfNodeIODataUtil.changeInputsToOutputs(inputs)`
- `WorkflowUtil.java:214` - Answer 节点：`NodeIOData.createByText("output", "", response)`
- `EndNode.java:52` - End 节点：`WorkflowUtil.renderTemplate(resultTemplate, state.getInputs())`

**模板渲染逻辑**：
- `WorkflowUtil.java:41-58` - 模板引擎：`result.replace("${" + name + "}", value.toString())`

**事件发送逻辑**：
- `WorkflowEngine.java:368-386` - INPUT 回调：跳过 Answer/SubWorkflow 节点
- `WorkflowEngine.java:403-419` - OUTPUT 回调：跳过 Start/Answer/SubWorkflow/End 节点

---

## 总结

**推荐方案**：方案一（修改结束节点配置）

**理由**：
1. 改动最小，风险可控
2. 符合工作流引擎设计理念
3. 快速见效，不影响其他功能

**下一步行动**：
1. 查看WorkflowEngine代码确认变量引用语法
2. 执行SQL更新结束节点配置
3. 测试验证效果
4. 如需彻底优化，再执行方案三
