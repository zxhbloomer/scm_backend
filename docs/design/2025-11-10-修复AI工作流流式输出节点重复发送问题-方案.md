# AI工作流流式输出节点重复发送问题修复方案

**文档编号**: SCM-AI-FIX-20251110-001
**创建日期**: 2025-11-10
**修复类型**: Bug修复
**影响范围**: WorkflowEngine核心逻辑

---

## 1. 问题描述

### 1.1 用户反馈

用户在使用AI工作流聊天功能时，前端收到了两段回复内容：
- **第一段**：JSON格式的结构化数据（NodeIOData对象的JSON字符串）
- **第二段**：正常的LLM文本回复

### 1.2 问题截图

用户提供的截图显示：
```
前端显示：
━━━━━━━━━━━━━━━━━━━
{
  "name": "output",
  "content": {
    "type": 1,
    "title": "",
    "value": "这是AI的回答内容..."
  }
}
━━━━━━━━━━━━━━━━━━━
这是AI的回答内容...
━━━━━━━━━━━━━━━━━━━
```

---

## 2. 问题根因分析

### 2.1 完整调用链路

```
AiConversationController
    ↓
WorkflowStarter.streaming()
    ↓
主工作流: sys-chat流程入口-v1 (UUID: 1746fd485e6c47c59f8b8e14e7bd7728)
    Start → ClassifierNode → SubWorkflowNode → End
                                    ↓
子工作流: scm智能助手-v1 (UUID: 14c91cd41e44490f885983703d53a31e)
    Start → LLMAnswerNode → End
                ↓
            streamingInvokeLLM()
                ↓
            流式输出到前端（通过NODE_CHUNK事件）
```

### 2.2 根因定位

**WorkflowEngine.java:384-389** 在节点执行完毕后，无条件发送NODE_OUTPUT事件：

```java
// 并行节点内部的节点执行结束后，需要主动向客户端发送输出结果
String nodeUuid = wfNode.getUuid();
List<NodeIOData> nodeOutputs = nodeState.getOutputs();
for (NodeIOData output : nodeOutputs) {
    streamHandler.sendNodeOutput(nodeUuid, JSONObject.toJSONString(output));  // ← 问题根源
}
```

**LLMAnswerNode** 已经通过 `WorkflowUtil.streamingInvokeLLM()` 流式输出了文本内容（NODE_CHUNK事件），但WorkflowEngine又发送了NODE_OUTPUT事件（包含完整的JSON数据），导致前端收到两次内容。

### 2.3 事件流分析

| 时间 | 事件类型 | 数据内容 | 前端显示 |
|------|---------|----------|---------|
| T1 | `[NODE_CHUNK_xxx]` | 文本块："这是AI的..." | 第二段（正常文本） |
| T2 | `[NODE_OUTPUT_xxx]` | JSON: `{"name":"output","content":{...}}` | 第一段（JSON字符串） |

---

## 3. 支撑数据

### 3.1 数据库数据

**ai_workflow_component 表**:
```sql
SELECT id, name, title FROM ai_workflow_component WHERE name = 'Answer';
-- 结果: id=3, name="Answer", title="生成回答"
```

**ai_workflow_node 表**:
```sql
SELECT n.id, n.uuid, n.title, wc.name as component_name
FROM ai_workflow_node n
LEFT JOIN ai_workflow_component wc ON n.workflow_component_id = wc.id
WHERE n.workflow_id = (SELECT id FROM ai_workflow WHERE workflow_uuid = '14c91cd41e44490f885983703d53a31e');
-- 结果: id=60, uuid="Fn1a2qM49ZgjDg7Ei3BtsKmHtHS4jfH", title="生成回答", component_name="Answer"
```

### 3.2 代码分析

**WorkflowEngine.java 关键代码**:
- Line 340: `AiWorkflowComponentEntity wfComponent = ...` - 获取组件对象
- Line 346: `AbstractWfNode abstractWfNode = WfNodeFactory.create(wfComponent, ...)` - 创建节点实例
- Line 384-389: 无条件发送NODE_OUTPUT事件（**问题代码**）

**LLMAnswerNode.java 关键代码**:
- Line 43: `WorkflowUtil.streamingInvokeLLM(...)` - 流式输出，已发送NODE_CHUNK事件

**WorkflowUtil.java 关键代码**:
- Line 167, 197: `wfState.getStreamHandler().sendNodeChunk(node.getUuid(), content)` - 发送流式块

### 3.3 前端代码验证

**前端处理逻辑** (`sseHandler.js`):
- Line 152-154: 处理NODE_CHUNK事件 → `handleNodeChunk()` → 显示流式文本
- Line 156-158: 处理NODE_OUTPUT事件 → `handleNodeOutput()` → 更新runtime node状态

**结论**: 前端只用NODE_OUTPUT更新状态，不依赖它显示内容。内容显示完全依赖NODE_CHUNK事件。

---

## 4. 方案设计

### 4.1 设计原则

1. **最小修改原则**: 只修改WorkflowEngine.java一个文件
2. **向后兼容原则**: 不影响其他15个非流式组件的行为
3. **KISS原则**: 用最简单的if判断解决问题

### 4.2 技术方案

**修改文件**: `WorkflowEngine.java`
**修改位置**: Line 384-389
**修改类型**: 添加条件判断

**修改前**:
```java
// 并行节点内部的节点执行结束后，需要主动向客户端发送输出结果
String nodeUuid = wfNode.getUuid();
List<NodeIOData> nodeOutputs = nodeState.getOutputs();
for (NodeIOData output : nodeOutputs) {
    streamHandler.sendNodeOutput(nodeUuid, JSONObject.toJSONString(output));
}
```

**修改后**:
```java
// 并行节点内部的节点执行结束后，需要主动向客户端发送输出结果
// 但是对于流式输出节点（Answer组件），已经通过NODE_CHUNK事件发送了内容，不需要再发送NODE_OUTPUT
String nodeUuid = wfNode.getUuid();
String componentName = wfComponent.getName(); // 获取组件名称

// 跳过流式输出节点的OUTPUT事件（LLMAnswerNode已通过CHUNK事件输出）
if (!"Answer".equals(componentName)) {
    List<NodeIOData> nodeOutputs = nodeState.getOutputs();
    for (NodeIOData output : nodeOutputs) {
        streamHandler.sendNodeOutput(nodeUuid, JSONObject.toJSONString(output));
    }
}
```

### 4.3 方案优势

1. **最小化修改**: 只增加3行代码（1行获取name + 1行if判断 + 1行注释）
2. **零破坏性**: 其他15个组件完全不受影响
3. **高可读性**: 注释清晰说明了为什么要跳过Answer组件
4. **易于维护**: 未来如果有其他流式组件，只需修改if条件

### 4.4 备选方案（不推荐）

**方案2: 前端过滤**
- 在前端忽略Answer节点的NODE_OUTPUT事件
- **缺点**: 不优雅，治标不治本，其他节点的OUTPUT事件是必要的

**方案3: 添加组件属性**
- 在ai_workflow_component表增加is_streaming字段
- **缺点**: 过度设计，只为一个组件增加字段太重

---

## 5. 影响范围

### 5.1 修改文件清单

**后端**:
- ✅ `scm-ai/src/main/java/com/xinyirun/scm/ai/workflow/WorkflowEngine.java` (修改3行)

**前端**:
- ❌ 无需修改

**数据库**:
- ❌ 无需修改

### 5.2 影响组件分析

| 组件名称 | 是否受影响 | 说明 |
|---------|----------|------|
| Answer | ✅ 影响 | 不再发送NODE_OUTPUT事件（这是修复目标） |
| Start | ❌ 不影响 | 继续发送OUTPUT事件 |
| End | ❌ 不影响 | 继续发送OUTPUT事件 |
| Classifier | ❌ 不影响 | 继续发送OUTPUT事件 |
| SubWorkflow | ❌ 不影响 | 继续发送OUTPUT事件 |
| KnowledgeRetrieval | ❌ 不影响 | 继续发送OUTPUT事件 |
| ... 其他10个组件 | ❌ 不影响 | 继续发送OUTPUT事件 |

---

## 6. KISS原则评估

### 6.1 四个关键问题

1. **"这是个真问题还是臆想出来的？"**
   - ✅ **真问题**！用户截图证实，前端确实收到了两段内容

2. **"有更简单的方法吗？"**
   - ✅ **已经是最简方案**！只需一个if判断，跳过Answer组件的OUTPUT事件

3. **"会破坏什么吗？"**
   - ✅ **不会破坏**！只修改Answer组件的行为，其他15个组件保持不变
   - ✅ 前端不依赖Answer的OUTPUT事件来显示内容

4. **"当前项目真的需要这个功能吗？"**
   - ✅ **必须修复**！这是一个严重影响用户体验的bug

### 6.2 复杂度评估

- **代码复杂度**: 极低（+3行代码）
- **理解复杂度**: 极低（注释清晰）
- **维护复杂度**: 极低（未来扩展只需修改if条件）
- **测试复杂度**: 低（只需测试Answer节点和一个其他节点）

---

## 7. 风险分析与缓解措施

### 7.1 潜在风险

| 风险项 | 概率 | 影响 | 缓解措施 |
|--------|------|------|---------|
| 前端依赖Answer的OUTPUT事件 | 低 | 中 | 已验证前端不依赖（见3.3节） |
| 其他组件被误判为Answer | 极低 | 高 | 使用精确匹配 `"Answer".equals(componentName)` |
| 未来新增流式组件 | 中 | 低 | 修改if条件，增加组件名称判断 |

### 7.2 回滚方案

如果发现问题，只需删除新增的3行代码，恢复原逻辑即可。回滚成本极低。

---

## 8. 测试计划

### 8.1 功能测试

**测试用例1: Answer节点流式输出**
- 输入：用户发送聊天消息
- 预期：前端只收到NODE_CHUNK事件，不收到NODE_OUTPUT事件
- 验证：前端只显示一段正常文本，不显示JSON

**测试用例2: 其他节点正常输出**
- 输入：触发ClassifierNode、SubWorkflowNode等其他节点
- 预期：前端正常收到NODE_OUTPUT事件
- 验证：runtime node状态正常更新

### 8.2 集成测试

**测试场景1: 主工作流包含子工作流**
- 工作流：sys-chat流程入口-v1 → scm智能助手-v1
- 预期：子工作流的Answer节点不发送OUTPUT，父工作流的ClassifierNode正常发送OUTPUT

**测试场景2: 多轮对话**
- 操作：连续发送3条消息
- 预期：每次都只收到一段文本回复，无JSON

---

## 9. 实施步骤

### 9.1 编码阶段

1. 修改 `WorkflowEngine.java:384-389`
2. 增加if条件判断，跳过Answer组件
3. 添加详细注释说明修改原因

### 9.2 测试阶段

1. 本地启动服务
2. 执行测试用例1和2
3. 验证前端显示正常
4. 检查日志无异常

### 9.3 部署阶段

1. 提交代码到Git
2. 触发CI/CD流程
3. 部署到测试环境验证
4. 部署到生产环境

---

## 10. 附录

### 10.1 相关文件路径

**后端核心文件**:
- `WorkflowEngine.java`: `D:\2025_project\20_project_in_github\00_scm_backend\scm_backend\scm-ai\src\main\java\com\xinyirun\scm\ai\workflow\WorkflowEngine.java`
- `LLMAnswerNode.java`: `D:\2025_project\20_project_in_github\00_scm_backend\scm_backend\scm-ai\src\main\java\com\xinyirun\scm\ai\workflow\node\answer\LLMAnswerNode.java`
- `WorkflowUtil.java`: `D:\2025_project\20_project_in_github\00_scm_backend\scm_backend\scm-ai\src\main\java\com\xinyirun\scm\ai\workflow\WorkflowUtil.java`

**前端核心文件**:
- `sseHandler.js`: `D:\2025_project\20_project_in_github\01_scm_frontend\scm_frontend\src\components\70_ai\components\workflow\utils\sseHandler.js`

### 10.2 参考资料

- 用户反馈截图：`D:\temp\20250813\新建 文本文档 (17) - 副本.txt`
- 问题排查日志：`D:\temp\20250813\新建 文本文档 (17).txt`

---

**方案制定人**: Claude (AI Assistant)
**方案评审**: 待用户审批
**预计实施时间**: 15分钟
**预计测试时间**: 10分钟
