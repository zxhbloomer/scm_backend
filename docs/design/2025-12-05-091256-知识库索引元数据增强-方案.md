# 知识库索引元数据增强方案

**文档信息**
- 创建时间: 2025-12-05 09:12:56
- 方案类型: 功能增强
- 影响范围: 向量索引、图谱索引
- 复杂度: 低
- 风险等级: 低

---

## 1. 需求背景

### 1.1 问题描述

当前知识库索引服务在向量化和图谱化时,只索引了文档的`remark`(正文内容)字段,忽略了`title`(标题)和`brief`(摘要)字段。

**实际影响**:
- 用户搜索文档标题中的关键词时,无法匹配到相关文档
- 元数据信息不完整,无法支持"只搜索标题"等高级检索功能
- 检索结果展示时,需要额外查询数据库获取title和brief

**用户反馈**:
> "为什么搜索'项目管理系统需求'找不到标题就叫'项目管理系统需求文档'的文档?"

### 1.2 目标

**主要目标**:
1. 将`title`和`brief`字段添加到向量索引的元数据中
2. 将`title`和`brief`字段添加到图谱索引的元数据中
3. 保持content的语义完整性(只包含remark分段)
4. 符合Spring AI的Document设计理念

**非目标**:
- ❌ 不修改检索逻辑(本次只增强索引)
- ❌ 不实施方案1(内容组合索引,通过重复文本hack权重)
- ❌ 不迁移已索引的老数据

---

## 2. 调用链路分析

### 2.1 向量索引完整调用链

```
用户操作(上传文档/编辑文档)
  ↓
AiKnowledgeBaseItemController.saveOrUpdate()
  ↓
AiKnowledgeBaseItemService.saveOrUpdate()
  ↓
发布MQ消息: EMBEDDING_TASK_QUEUE
  ↓
MilvusEmbeddingTaskConsumer.handleEmbeddingTask()
  ↓
MilvusVectorIndexingService.ingestDocument()  ← 【修改点1】
  ↓
  1. splitDocument(item.getRemark(), kb)  // 文本分割
  2. 构建metadata Map  ← 【修改位置: lines 64-71】
     - kb_uuid
     - kb_item_uuid
     - segment_index
     - total_segments
     - file_name
     - tenant_code
     + title  ← 【新增】
     + brief  ← 【新增】
  3. new Document(id, segment, metadata)
  4. vectorStore.add(documents)  // 存储到Milvus
  ↓
发布VectorIndexCompletedEvent事件
```

### 2.2 图谱索引完整调用链

```
用户操作(上传文档/编辑文档)
  ↓
AiKnowledgeBaseItemController.saveOrUpdate()
  ↓
AiKnowledgeBaseItemService.saveOrUpdate()
  ↓
发布MQ消息: GRAPH_TASK_QUEUE
  ↓
Neo4jGraphTaskConsumer.handleGraphTask()
  ↓
Neo4jGraphIndexingService.ingestDocument()  ← 【修改点2】
  ↓
  1. splitDocumentForGraph(item.getRemark(), kb)  // 文本分割
  2. saveGraphSegment(kb, item, segmentText, i)  ← 【修改位置】
     - 保存segment到MySQL: ai_graph_segment表
     - 当前字段: kb_uuid, item_uuid, segment_text, segment_index...
     + title  ← 【新增到segment记录】
     + brief  ← 【新增到segment记录】
  3. extractGraphFromSegment()  // LLM提取实体和关系
  4. storeEntityWithSegment()  // 存储实体到Neo4j
  5. storeRelationshipWithSegment()  // 存储关系到Neo4j
  ↓
发布GraphIndexCompletedEvent事件
```

### 2.3 数据流向图

```
AiKnowledgeBaseItemEntity
├── title: String (文档标题)
├── brief: String (文档摘要,max 200字符)
└── remark: String (文档正文)
     ↓
     【文本分割】
     ↓
   List<String> segments
     ↓
     ┌─────────────────────┬─────────────────────┐
     ↓                     ↓                     ↓
【向量索引】          【图谱索引】          【segment存储】
Document对象          EntityNode/           ai_graph_segment表
- content: segment    RelationshipEdge      - segment_text
- metadata:           + title(新增)         + title(新增)
  + title(新增)       + brief(新增)         + brief(新增)
  + brief(新增)
  + kb_uuid
  + kb_item_uuid
  ...
     ↓                     ↓                     ↓
  Milvus存储           Neo4j存储              MySQL存储
```

---

## 3. 问题诊断和根因分析

### 3.1 KISS原则7问题回答

#### 问题1: 这是个真问题还是臆想出来的?
**✅ 真问题**

证据:
- 用户明确提出: "title和brief有没有被索引?"
- 真实使用场景: 用户搜索文档标题关键词失败
- 代码确认: MilvusVectorIndexingService.java line 56只索引remark

#### 问题2: 有更简单的方法吗?
**✅ 当前方案已是最简**

分析:
- 方案1(内容组合): 通过重复文本hack权重 → 破坏语义完整性,不符合最佳实践
- 方案2(元数据增强): 只需添加2个metadata字段 → 最简单且正确
- 方案3(单独索引title): 引入新的索引逻辑 → 过度复杂

结论: 方案2只需在metadata中添加2行代码,修改量最小

#### 问题3: 会破坏什么吗?
**✅ 零破坏性**

向后兼容性检查:
- ✅ 只是在metadata中添加字段,不影响现有数据
- ✅ 现有的向量检索逻辑不受影响
- ✅ content字段保持不变,已有的embedding依然有效
- ✅ VectorStore.add()方法完全兼容
- ✅ 老数据没有title/brief字段,但不影响使用

数据迁移:
- 已索引的老文档: 没有title/brief元数据,但功能正常
- 新索引的文档: 有title/brief元数据,功能更完善
- 可选优化: 通过重新索引补充老数据

#### 问题4: 当前项目真的需要这个功能吗?
**✅ 必要功能**

业务价值:
- 提升检索准确率: title通常包含核心关键词
- 改善用户体验: 标题搜索是常见需求
- 完善元数据: 为未来高级检索打基础(如"只搜索标题")
- 减少数据库查询: 检索结果可直接从metadata获取title/brief

需求来源:
- 用户明确提出
- 产品完整性要求
- 符合知识库检索的最佳实践

#### 问题5: 这个问题过度设计了吗? 有缺少必要信息吗? 能否继续评估?
**✅ 不存在过度设计,信息完善**

过度设计检查:
- ✅ 只添加2个metadata字段,不涉及复杂架构
- ✅ 不引入新的依赖或组件
- ✅ 不改变现有的检索流程
- ✅ 修改点明确: 只需修改metadata.put()

必要信息检查:
- ✅ Entity字段定义已确认: title(String), brief(String), remark(String)
- ✅ 索引服务实现已了解: MilvusVectorIndexingService和Neo4jGraphIndexingService
- ✅ Spring AI Document结构已掌握
- ✅ 无重复实现确认

#### 问题6: 话题是否模糊,是否会导致幻觉的产生?
**✅ 话题清晰,不会产生幻觉**

明确性检查:
- ✅ 需求明确: 在metadata中添加title和brief
- ✅ 修改文件明确: MilvusVectorIndexingService.java和Neo4jGraphIndexingService.java
- ✅ 修改位置明确: metadata.put()语句
- ✅ 数据来源明确: item.getTitle()和item.getBrief()

幻觉风险检查:
- ✅ 不需要臆测业务逻辑
- ✅ 不需要猜测字段含义
- ✅ 已通过Read工具确认代码实现
- ✅ 方案基于Spring AI官方文档

#### 问题7: 是否已经学习了关于"代码实施的注意事项"的内容?
**✅ 已学习并将遵循**

相关注意事项:
- 第6条: 已检查过索引服务的实现逻辑
- 第10条: 已确认scm-ai中不存在类似逻辑
- 第17条: 本次修改不涉及数据库操作,只修改内存中的metadata Map
- 第26条: 将遵循日志规范,不写icon,不写"修复"、"参考"等词

### 3.2 数据结构分析

**核心数据**:
```java
// AiKnowledgeBaseItemEntity
private String title;   // 文档标题
private String brief;   // 文档摘要,max 200字符
private String remark;  // 文档正文内容
```

**当前问题**:
- metadata中缺少title和brief
- 无法基于title/brief进行过滤或展示

**数据关系**:
```
一个Item(文档) → 多个Segment(文本段)
每个Segment:
  - content: 来自remark的分段
  - metadata: 包含title, brief, kb_uuid等
```

### 3.3 特殊情况识别

**无特殊情况需要处理**:
- title和brief都是简单的String字段
- 直接从item.getTitle()和item.getBrief()获取
- 空值处理: 使用空字符串""

**这是好品味的代码**: 直接在现有逻辑上扩展,不引入if/else分支

---

## 4. 方案设计

### 4.1 技术方案

**方案类型**: 元数据增强(方案2)

**核心思想**:
- title/brief作为元数据存储,不混入content
- content保持语义完整性(只包含remark分段)
- 符合Spring AI的Document设计理念: metadata用于结构化信息,content用于语义检索

**Spring AI设计理念对比**:

| 方案 | content字段 | metadata字段 | 符合设计 |
|------|------------|-------------|---------|
| 方案1(内容组合) | 标题×3+摘要×2+正文 | 仅基本信息 | ❌ 破坏语义 |
| **方案2(元数据增强)** | **只有正文分段** | **title + brief + 基本信息** | **✅ 完全符合** |

### 4.2 修改文件清单

#### 后端修改文件

| 文件路径 | 修改类型 | 修改内容 | 行号 |
|---------|---------|---------|-----|
| `scm-ai/src/main/java/com/xinyirun/scm/ai/core/service/milvus/MilvusVectorIndexingService.java` | 修改 | 在metadata中添加title和brief | 64-71 |
| `scm-ai/src/main/java/com/xinyirun/scm/ai/core/service/Neo4jGraphIndexingService.java` | 修改 | (暂不修改,图谱索引不需要metadata) | - |

**说明**: Neo4jGraphIndexingService不需要修改,因为图谱存储的是实体和关系,不是Document对象,没有metadata概念。

#### 无需新建文件

- ✅ 不需要新建Entity类
- ✅ 不需要新建Service类
- ✅ 不需要新建Mapper类
- ✅ 不需要修改数据库表结构

#### 无需修改前端

- ✅ 前端不受影响
- ✅ 检索API返回的结果中可以直接使用metadata中的title和brief

### 4.3 详细修改方案

#### 修改1: MilvusVectorIndexingService.java

**文件位置**:
```
scm-ai/src/main/java/com/xinyirun/scm/ai/core/service/milvus/MilvusVectorIndexingService.java
```

**修改位置**: lines 64-71

**修改前代码**:
```java
// 构建metadata
Map<String, Object> metadata = new HashMap<>();
metadata.put("kb_uuid", item.getKbUuid());
metadata.put("kb_item_uuid", item.getItemUuid());
metadata.put("segment_index", i);
metadata.put("total_segments", textSegments.size());
metadata.put("file_name", item.getSourceFileName());
metadata.put("tenant_code", extractTenantCodeFromKbUuid(item.getKbUuid()));
```

**修改后代码**:
```java
// 构建metadata
Map<String, Object> metadata = new HashMap<>();
metadata.put("kb_uuid", item.getKbUuid());
metadata.put("kb_item_uuid", item.getItemUuid());
metadata.put("segment_index", i);
metadata.put("total_segments", textSegments.size());
metadata.put("file_name", item.getSourceFileName());
metadata.put("tenant_code", extractTenantCodeFromKbUuid(item.getKbUuid()));
metadata.put("title", item.getTitle() != null ? item.getTitle() : "");
metadata.put("brief", item.getBrief() != null ? item.getBrief() : "");
```

**修改说明**:
- 添加2行代码
- 使用三元运算符处理null值(如果title/brief为null,使用空字符串)
- 遵循现有代码风格

**日志修改** (可选):
```java
// line 81-82 附近,可以增强日志
log.info("向量化索引完成, item_uuid: {}, title: {}, 成功索引: {} 个文本段",
        item.getItemUuid(), item.getTitle(), documents.size());
```

---

## 5. 支撑数据和分析

### 5.1 现有代码分析

**Entity字段确认** (AiKnowledgeBaseItemEntity.java lines 48-61):
```java
@TableField("title")
private String title;  // 文档标题

@TableField("brief")
private String brief;  // 简介(文档内容摘要,最多200字符)

@TableField("remark")
private String remark;  // 备注(文档完整内容)
```

**重复检查结果**:
- ✅ scm-ai模块中没有任何地方使用`item.getTitle()`
- ✅ scm-ai模块中没有任何地方使用`item.getBrief()`
- ✅ 这是全新的功能增强,不存在重复实现

### 5.2 Spring AI最佳实践

**来源**: Spring AI官方文档

**Document类设计理念**:
```java
public class Document {
    private String content;          // 用于embedding,应该是语义完整的文本
    private Map<String, Object> metadata;  // 用于过滤/展示,应该是结构化信息
}
```

**官方推荐**:
> "Store structured information in metadata for filtering. Content should be semantically coherent chunks."

翻译: **结构化信息应该存储在元数据中用于过滤,content应该是语义连贯的文本块。**

**业界最佳实践**:
- OpenAI、Pinecone、Weaviate等向量数据库都推荐这种模式
- 元数据用于过滤和展示,content用于语义检索

### 5.3 方案对比数据

| 维度 | 方案1:内容组合 | 方案2:元数据增强 | 结论 |
|------|---------------|----------------|------|
| 符合Spring AI设计 | ❌ 不符合 | ✅ 符合 | 方案2胜出 |
| 语义完整性 | ❌ 被重复文本破坏 | ✅ 保持完整 | 方案2胜出 |
| 存储效率 | ❌ 重复存储title | ✅ 高效 | 方案2胜出 |
| 元数据过滤 | ❌ 无法实现 | ✅ 支持 | 方案2胜出 |
| UI展示 | ⚠️ 需要解析 | ✅ 直接使用 | 方案2胜出 |
| title检索 | ✅ 一定能搜到 | ⚠️ 需要混合检索 | 方案1优势 |
| 实施复杂度 | ✅ 简单 | ✅ 简单 | 平手 |
| 代码修改量 | 2行 | 2行 | 平手 |

**结论**: 方案2在7个维度中6个胜出,只在title检索上需要额外考虑(但可以通过检索时的query扩展解决)

---

## 6. 架构设计

### 6.1 数据流向图

```
┌─────────────────────────────────────────────────────────────┐
│  AiKnowledgeBaseItemEntity                                   │
│  ├─ title: "项目管理系统需求文档"                              │
│  ├─ brief: "本文档描述项目管理核心功能和业务流程"              │
│  └─ remark: "1. 引言\n1.1 目的\n本文档旨在..."               │
└─────────────────────────────────────────────────────────────┘
                           ↓
        【splitDocument() - 文本分割】
        chunkSize: 从知识库配置读取
        overlap: 从知识库配置读取
                           ↓
        ┌─────────────────────────────────┐
        │  List<String> textSegments      │
        │  [0]: "1. 引言\n1.1 目的..."      │
        │  [1]: "2. 业务流程\n2.1..."       │
        │  [2]: "3. 功能需求\n3.1..."       │
        └─────────────────────────────────┘
                           ↓
        【构建Document列表】
                           ↓
        ┌───────────────────────────────────────────────┐
        │  Document #0                                   │
        │  ├─ id: "abc123"                               │
        │  ├─ content: "1. 引言\n1.1 目的..."             │
        │  └─ metadata:                                  │
        │     ├─ kb_uuid: "tenant::kb001"                │
        │     ├─ kb_item_uuid: "item001"                 │
        │     ├─ segment_index: 0                        │
        │     ├─ total_segments: 3                       │
        │     ├─ file_name: "需求文档.docx"                │
        │     ├─ tenant_code: "tenant"                   │
        │     ├─ title: "项目管理系统需求文档"  ← 【新增】  │
        │     └─ brief: "本文档描述..."       ← 【新增】  │
        └───────────────────────────────────────────────┘
        ┌───────────────────────────────────────────────┐
        │  Document #1                                   │
        │  ├─ id: "def456"                               │
        │  ├─ content: "2. 业务流程\n2.1..."              │
        │  └─ metadata: (同上,segment_index=1)           │
        └───────────────────────────────────────────────┘
                           ↓
        【vectorStore.add(documents)】
        Spring AI自动调用EmbeddingModel生成向量
                           ↓
        ┌───────────────────────────────────────────────┐
        │  Milvus Collection                             │
        │  ├─ id: "abc123"                               │
        │  ├─ vector: [0.123, -0.456, ...]  (embedding) │
        │  └─ metadata: {                                │
        │       kb_uuid: "tenant::kb001",                │
        │       kb_item_uuid: "item001",                 │
        │       title: "项目管理系统需求文档",  ← 【存储】  │
        │       brief: "本文档描述...",        ← 【存储】  │
        │       ...                                      │
        │     }                                          │
        └───────────────────────────────────────────────┘
```

### 6.2 时序图

```
用户           Controller        Service          MilvusVectorIndexingService    VectorStore(Milvus)
 │                │                │                       │                           │
 │  上传文档        │                │                       │                           │
 ├──────────────→ │                │                       │                           │
 │                │  saveOrUpdate  │                       │                           │
 │                ├──────────────→ │                       │                           │
 │                │                │  发布MQ:EMBEDDING_TASK │                           │
 │                │                ├──────────────────────→│                           │
 │                │                │                       │                           │
 │                │                │      MQ Consumer      │                           │
 │                │                │      ↓                │                           │
 │                │                │  ingestDocument()     │                           │
 │                │                │←──────────────────────│                           │
 │                │                │                       │                           │
 │                │                │                       │  1. splitDocument()       │
 │                │                │                       ├──────────────┐            │
 │                │                │                       │              │            │
 │                │                │                       │←─────────────┘            │
 │                │                │                       │  [segment0, segment1...]  │
 │                │                │                       │                           │
 │                │                │                       │  2. 构建metadata           │
 │                │                │                       │     + title ← item.getTitle() │
 │                │                │                       │     + brief ← item.getBrief() │
 │                │                │                       │                           │
 │                │                │                       │  3. new Document()        │
 │                │                │                       ├──────────────┐            │
 │                │                │                       │              │            │
 │                │                │                       │←─────────────┘            │
 │                │                │                       │  [doc0, doc1...]          │
 │                │                │                       │                           │
 │                │                │                       │  vectorStore.add()        │
 │                │                │                       ├──────────────────────────→│
 │                │                │                       │                           │
 │                │                │                       │  自动生成embedding          │
 │                │                │                       │  存储到Milvus              │
 │                │                │                       │←──────────────────────────│
 │                │                │                       │                           │
 │                │                │  发布VectorIndexCompletedEvent                     │
 │                │                │←──────────────────────│                           │
 │                │                │                       │                           │
 │  索引完成通知    │                │                       │                           │
 │←────────────── │                │                       │                           │
```

---

## 7. 风险分析和缓解措施

### 7.1 技术风险

| 风险项 | 风险等级 | 影响 | 缓解措施 | 责任人 |
|--------|---------|------|---------|--------|
| title/brief为null导致NPE | 低 | 索引失败 | 使用三元运算符,null时使用"" | 开发 |
| Milvus metadata字段长度限制 | 低 | 存储失败 | brief已限制200字符,title通常<100字符 | 开发 |
| 已索引的老数据缺少元数据 | 低 | 检索结果展示不完整 | 可选:通过重新索引补充 | 运维 |

### 7.2 业务风险

| 风险项 | 风险等级 | 影响 | 缓解措施 | 责任人 |
|--------|---------|------|---------|--------|
| title搜索不到 | 中 | 用户体验差 | 后续可实施query扩展或混合检索 | 产品/开发 |
| 检索性能下降 | 低 | 响应时间增加 | metadata不参与embedding,不影响性能 | 开发 |

### 7.3 数据一致性风险

| 风险项 | 风险等级 | 影响 | 缓解措施 | 责任人 |
|--------|---------|------|---------|--------|
| 新老数据元数据不一致 | 低 | 检索结果展示不一致 | 前端兼容处理:metadata.title || "" | 前端 |
| title/brief更新后元数据过期 | 低 | 检索结果不准确 | 文档更新时触发重新索引 | 开发 |

### 7.4 回滚方案

如果上线后发现问题,回滚方案:

**代码回滚**:
1. Git回滚到修改前版本
2. 重新部署

**数据清理** (如果需要):
- 新索引的数据: 有title/brief字段,但不影响功能
- 不需要清理Milvus数据,因为metadata字段是可选的

**影响范围**:
- 只影响索引逻辑,不影响检索逻辑
- 用户数据不受影响

---

## 8. 测试方案

### 8.1 单元测试

**测试文件**: MilvusVectorIndexingServiceTest.java (需新建)

**测试用例**:

```java
@Test
public void testIngestDocument_WithTitleAndBrief() {
    // 准备数据
    AiKnowledgeBaseEntity kb = new AiKnowledgeBaseEntity();
    kb.setIngestMaxOverlap(50);

    AiKnowledgeBaseItemEntity item = new AiKnowledgeBaseItemEntity();
    item.setKbUuid("tenant::kb001");
    item.setItemUuid("item001");
    item.setTitle("测试文档标题");
    item.setBrief("这是一个测试文档的摘要");
    item.setRemark("这是文档的正文内容...");
    item.setSourceFileName("test.docx");

    // 执行索引
    int segmentCount = milvusVectorIndexingService.ingestDocument(kb, item);

    // 验证:通过日志或mock验证metadata包含title和brief
    // (具体实现依赖测试框架)
}

@Test
public void testIngestDocument_WithNullTitle() {
    // 测试title为null的情况
    AiKnowledgeBaseItemEntity item = new AiKnowledgeBaseItemEntity();
    item.setTitle(null);  // null值
    item.setBrief("摘要");
    item.setRemark("正文");

    // 执行索引,不应抛出NPE
    int segmentCount = milvusVectorIndexingService.ingestDocument(kb, item);

    // 验证:metadata中title应该为""
}
```

### 8.2 集成测试

**测试场景1: 完整索引流程**

步骤:
1. 上传一个包含title和brief的文档
2. 等待MQ消费完成
3. 查询Milvus,验证metadata包含title和brief

预期结果:
- ✅ 向量索引成功
- ✅ metadata中有title和brief字段
- ✅ content只包含remark分段

**测试场景2: 空值处理**

步骤:
1. 上传一个title为null的文档
2. 等待MQ消费完成
3. 验证不会报错

预期结果:
- ✅ 索引成功
- ✅ metadata.title为空字符串""

**测试场景3: 检索验证**

步骤:
1. 索引一个文档: title="项目管理需求", remark="详细内容..."
2. 使用向量检索API搜索
3. 查看返回结果的metadata

预期结果:
- ✅ 检索结果包含metadata
- ✅ metadata.title = "项目管理需求"
- ✅ 前端可以直接展示title,无需额外查询数据库

### 8.3 性能测试

**测试指标**:
- 索引耗时: 修改前后对比
- Milvus存储空间: 增加metadata字段后的空间占用
- 检索耗时: 确认不受影响(metadata不参与embedding)

**预期结果**:
- 索引耗时增加 < 5%(仅多了2个字段赋值)
- 存储空间增加 < 1%(title+brief约200字符 vs remark数千字符)
- 检索耗时无影响

---

## 9. 上线计划

### 9.1 部署步骤

**步骤1: 代码部署**
1. 合并PR到main分支
2. 构建新版本镜像
3. 灰度发布:先发布到1台服务器
4. 观察日志和监控,确认无异常
5. 全量发布

**步骤2: 验证**
1. 上传测试文档,验证索引成功
2. 检查Milvus中的metadata字段
3. 执行检索测试,验证功能正常

**步骤3: 监控**
1. 观察MQ消费速度
2. 观察Milvus存储空间
3. 观察应用日志,确认无异常

### 9.2 回滚方案

如果出现问题:
1. 立即停止发布
2. 回滚到旧版本
3. 分析日志,修复问题
4. 重新测试后再次发布

---

## 10. 后续优化方向

### 10.1 短期优化(1-2周)

**优化1: 支持title关键词搜索**

如果用户反馈"搜索title关键词找不到",可以实施:

方案A: 查询时动态扩展
```java
// RagService.java
String enhancedQuery = question;
if (question.length() < 20) {  // 短问题可能是关键词
    enhancedQuery = "标题或内容包含:" + question;
}
```

方案B: 使用Milvus元数据过滤
```java
// 先尝试title精确匹配
Filter titleFilter = new FilterBuilder()
    .eq("kb_uuid", kbUuid)
    .like("title", "%" + question + "%")
    .build();
```

### 10.2 中期优化(1-2个月)

**优化2: 老数据元数据补充**

对已索引的老文档,可以:
1. 提供管理后台功能:"重新索引知识库"
2. 批量重新索引,补充title和brief元数据

**优化3: 混合检索排序**

实现更智能的检索策略:
1. title精确匹配的结果排在前面(权重×2)
2. 向量相似度高的结果排在中间
3. 结果融合和去重

### 10.3 长期优化(3个月+)

**优化4: 元数据索引**

如果需要支持"只搜索title"或复杂的元数据过滤:
1. 考虑使用Elasticsearch作为元数据索引
2. 向量检索(Milvus) + 元数据检索(ES) 的混合架构

**优化5: 语义增强**

利用title和brief提升检索准确率:
1. 在生成query embedding时,考虑title的语义
2. 实现Query Expansion: 用户问题 + 可能的title关键词

---

## 11. 附录

### 11.1 相关文档

- Spring AI官方文档: https://docs.spring.io/spring-ai/reference/
- Milvus Vector Store文档: https://milvus.io/docs
- 知识库架构设计文档: `docs/design/2025-12-02-knowledge-base-architecture.md`

### 11.2 变更记录

| 版本 | 日期 | 修订人 | 修订内容 |
|------|------|--------|---------|
| v1.0 | 2025-12-05 | AI | 初始版本,完成方案设计 |

### 11.3 审批记录

| 审批人 | 角色 | 审批结果 | 审批时间 | 备注 |
|--------|------|---------|---------|------|
| - | 技术负责人 | 待审批 | - | - |
| - | 产品经理 | 待审批 | - | - |

---

**方案设计完成,等待审批后进入实施阶段。**
