# 多轮对话记忆内容格式修复方案

## 问题描述

### 现象
在`ai_workflow_conversation_content`表中，保存的用户消息内容不是纯粹的用户输入，而是包含了完整的prompt模板内容，包括系统指令。

**实际保存的内容**：
```
【用户问题】：我是小王

【分类结果】：未知请求 / 不确定

【任务】：
用户的问题不够明确，无法准确理解意图。请生成一个友好的回复：

1. 不需要完整重复用户的问题，但可以自然地引用关键词
2. 礼貌地表示当前问题不够清晰
3. 具体说明哪里不明确...
（大量系统指令）
```

**期望保存的内容**：
```
我是小王
```

### 影响
- AI无法正确理解对话历史，因为它看到的是系统指令而不是纯用户消息
- 多轮对话记忆功能失效
- 测试用例：第一个问题"我是小王" → 第二个问题"我是谁" → AI应该回答"你是小王"，但实际无法正确回答

## 根因分析

### 完整调用链路

1. **LLMAnswerNode.onProcess()** (line 34-39)
   ```java
   // 构建最终的提示词
   String prompt = inputText;
   if (StringUtils.isNotBlank(nodeConfig.getPrompt())) {
       prompt = WorkflowUtil.renderTemplate(nodeConfig.getPrompt(), state.getInputs());
   }
   ```
   - 从数据库读取prompt模板：`【用户问题】：${var_user_input}\n\n【分类结果】：...\n\n【任务】：...`
   - 使用`WorkflowUtil.renderTemplate()`渲染，将`${var_user_input}`替换为`我是小王`
   - 生成完整的prompt

2. **WorkflowUtil.streamingInvokeLLM()** (line 176)
   ```java
   aiChatBaseService.chatWithWorkflowMemoryStream(chatOption, runtimeUuid)
   ```
   - `chatOption.setPrompt(prompt)` - 这里的prompt已经是完整的渲染后内容

3. **AiChatBaseService.chatWithWorkflowMemoryStream()** (line 211)
   ```java
   .user(aiChatOption.getPrompt())
   ```
   - 将完整的prompt作为user消息传递给ChatClient

4. **WorkflowConversationAdvisor.adviseStream()** (line 123)
   ```java
   String userContent = request.prompt().getUserMessage().getText();
   ```
   - 获取的是**完整的渲染后prompt**，不是原始用户输入
   - 将这个完整prompt保存到数据库

### 问题本质

WorkflowConversationAdvisor保存的是"发送给AI的完整prompt"，而不是"用户的原始输入"。

## 解决方案设计

### 方案对比

#### 方案A：通过Advisor参数传递原始用户输入（推荐）
**优点**：
- 符合Spring AI的设计理念
- 代码清晰，职责明确
- 易于扩展和维护
- 不破坏现有架构

**缺点**：
- 需要修改多个文件
- 需要确定"原始用户输入"的定义

**实施步骤**：
1. 在`WorkflowUtil.streamingInvokeLLM()`中，从`wfState.getInputs()`提取原始用户输入
2. 传递给`aiChatBaseService.chatWithWorkflowMemoryStream()`
3. 在`chatWithWorkflowMemoryStream()`中，通过Advisor参数传递
4. `WorkflowConversationAdvisor`优先使用此参数

#### 方案B：在invokeLLM()中直接保存消息
**优点**：
- 不依赖Advisor
- 逻辑直接清晰

**缺点**：
- 破坏了Spring AI的Advisor架构
- 增加了工具类的职责
- 与Chat领域的记忆机制不一致

#### 方案C：从prompt中提取用户输入
**优点**：
- 无需修改调用链路

**缺点**：
- 不够稳定，prompt模板可能变化
- 正则表达式容易出错
- 无法处理复杂的模板格式

### 选定方案：方案A

#### 详细设计

##### 1. 定义"原始用户输入"

**关键问题**：什么是"原始用户输入"？

**答案**：在工作流中，原始用户输入是**开始节点的输出参数`var_user_input`的值**。

**证据**：
- 从开始节点的配置可以看到，用户输入被存储为`var_user_input`
- Prompt模板中使用`${var_user_input}`引用用户输入
- 这是整个工作流的第一个用户交互输入

##### 2. 提取原始用户输入的逻辑

在`WorkflowUtil.streamingInvokeLLM()`中：
```java
// 从wfState.getInputs()中提取原始用户输入
String originalUserInput = null;
for (NodeIOData input : wfState.getInput()) {
    if ("var_user_input".equals(input.getName())) {
        originalUserInput = input.valueToString();
        break;
    }
}
```

**注意**：
- 使用`wfState.getInput()`而不是`nodeState.getInputs()`
- 因为`wfState.getInput()`是整个工作流的初始输入
- `nodeState.getInputs()`是当前节点的输入，可能已经被处理过

##### 3. 修改文件清单

**文件1：WorkflowUtil.java**
- 位置：`scm-ai/src/main/java/com/xinyirun/scm/ai/workflow/WorkflowUtil.java`
- 修改：`streamingInvokeLLM()`方法
- 变更：
  - 提取原始用户输入
  - 传递给`aiChatBaseService.chatWithWorkflowMemoryStream()`

**文件2：AiChatBaseService.java**
- 位置：`scm-ai/src/main/java/com/xinyirun/scm/ai/core/service/chat/AiChatBaseService.java`
- 修改：`chatWithWorkflowMemoryStream()`方法
- 变更：
  - 添加`originalUserInput`参数
  - 通过Advisor参数传递

**文件3：WorkflowConversationAdvisor.java**
- 位置：`scm-ai/src/main/java/com/xinyirun/scm/ai/config/memory/WorkflowConversationAdvisor.java`
- 修改：`adviseStream()`和`adviseCall()`方法
- 变更：
  - 添加新的参数键`ORIGINAL_USER_INPUT`
  - 优先使用`ORIGINAL_USER_INPUT`参数
  - 降级使用`request.prompt().getUserMessage().getText()`

##### 4. 代码设计

**WorkflowUtil.java修改**：
```java
public static void streamingInvokeLLM(WfState wfState, WfNodeState nodeState, AiWorkflowNodeVo node,
                                       String modelName, String prompt) {
    String conversationId = wfState.getConversationId();

    // *** 新增：提取原始用户输入 ***
    String originalUserInput = extractOriginalUserInput(wfState);

    log.info("invoke LLM (streaming), modelName: {}, conversationId: {}, originalUserInput: {}, prompt length: {}",
            modelName, conversationId, originalUserInput,
            StringUtils.isNotBlank(prompt) ? prompt.length() : 0);

    // ... existing code ...

    // *** 修改：传递originalUserInput ***
    aiChatBaseService.chatWithWorkflowMemoryStream(chatOption, runtimeUuid, originalUserInput)
        .chatResponse()
        // ... rest of code
}

/**
 * 提取原始用户输入
 * 从工作流初始输入中提取var_user_input参数的值
 */
private static String extractOriginalUserInput(WfState wfState) {
    if (wfState.getInput() == null) {
        return null;
    }

    for (NodeIOData input : wfState.getInput()) {
        if ("var_user_input".equals(input.getName())) {
            return input.valueToString();
        }
    }

    return null;
}
```

**AiChatBaseService.java修改**：
```java
/**
 * Workflow领域专用流式对话（带记忆）
 *
 * @param aiChatOption 对话选项
 * @param runtimeUuid 运行时UUID
 * @param originalUserInput 原始用户输入（用于对话记录，而不是渲染后的prompt）
 * @return ChatClient.StreamResponseSpec
 */
public ChatClient.StreamResponseSpec chatWithWorkflowMemoryStream(
        AIChatOptionVo aiChatOption,
        String runtimeUuid,
        String originalUserInput) {  // *** 新增参数 ***

    log.info("🚀 [Workflow Memory] 调用chatWithWorkflowMemoryStream - conversationId: {}, runtimeUuid: {}, originalUserInput: {}, prompt长度: {}",
            aiChatOption.getConversationId(),
            runtimeUuid,
            originalUserInput,
            aiChatOption.getPrompt() != null ? aiChatOption.getPrompt().length() : 0);

    return workflowDomainChatClient
        .prompt()
        .system(aiChatOption.getSystem())
        .user(aiChatOption.getPrompt())
        .advisors(a -> {
            a.param(ChatMemory.CONVERSATION_ID, aiChatOption.getConversationId());
            a.param(WorkflowConversationAdvisor.RUNTIME_UUID, runtimeUuid);

            // *** 新增：传递原始用户输入 ***
            if (StringUtils.isNotBlank(originalUserInput)) {
                a.param(WorkflowConversationAdvisor.ORIGINAL_USER_INPUT, originalUserInput);
            }
        })
        .stream();
}
```

**WorkflowConversationAdvisor.java修改**：
```java
public class WorkflowConversationAdvisor implements CallAdvisor, StreamAdvisor {

    public static final String RUNTIME_UUID = "WORKFLOW_RUNTIME_UUID";

    /**
     * 原始用户输入参数键
     * 用于保存纯粹的用户输入，而不是渲染后的prompt
     */
    public static final String ORIGINAL_USER_INPUT = "ORIGINAL_USER_INPUT";  // *** 新增 ***

    @Override
    public Flux<ChatClientResponse> adviseStream(ChatClientRequest request, StreamAdvisorChain chain) {
        String conversationId = (String) request.context().get(ChatMemory.CONVERSATION_ID);
        String runtimeUuid = (String) request.context().get(RUNTIME_UUID);

        if (conversationId != null && runtimeUuid != null) {
            // *** 修改：优先使用原始用户输入 ***
            String originalUserInput = (String) request.context().get(ORIGINAL_USER_INPUT);

            String userContent;
            if (StringUtils.isNotBlank(originalUserInput)) {
                // 使用原始用户输入（推荐）
                userContent = originalUserInput;
                log.info("👤 [WorkflowConversationAdvisor] 使用原始用户输入, 长度: {}", userContent.length());
            } else {
                // 降级：使用完整prompt（兼容旧代码）
                userContent = request.prompt().getUserMessage().getText();
                log.warn("⚠️ [WorkflowConversationAdvisor] ORIGINAL_USER_INPUT为空，降级使用完整prompt, 长度: {}",
                    userContent != null ? userContent.length() : 0);
            }

            if (userContent != null && !userContent.isEmpty()) {
                saveMessage(conversationId, runtimeUuid, AiMessageTypeConstant.MESSAGE_TYPE_USER, userContent);
            }
        }

        // ... rest of code remains the same
    }

    // adviseCall()方法做同样的修改
}
```

### KISS原则4问题验证

#### 1. 这是个真问题还是臆想出来的？
**答案**：**真问题**

**证据**：
- 数据库查询结果显示实际保存了完整prompt模板
- 测试用例失败：第二个问题"我是谁"无法得到正确回答
- 日志显示历史记录被正确查询和传递，但内容格式错误

#### 2. 有更简单的方法吗？
**答案**：**当前方案已是最简方案**

**对比**：
- ❌ 正则提取：不稳定，容易出错
- ❌ 直接保存：破坏架构
- ✅ Advisor参数：符合设计理念，代码清晰

**简化点**：
- 只修改3个文件
- 只新增1个方法（extractOriginalUserInput）
- 只新增1个参数传递

#### 3. 会破坏什么吗？
**答案**：**零破坏**

**向后兼容性**：
- `ORIGINAL_USER_INPUT`参数是可选的
- 如果为空，降级使用原有逻辑
- 不影响Chat领域的对话记忆（使用不同的Advisor）
- 不影响无记忆模式的工作流

**风险评估**：
- 🟢 低风险：只影响Workflow领域的对话记录
- 🟢 可回滚：参数传递失败时自动降级
- 🟢 可测试：通过对话内容长度验证是否生效

#### 4. 当前项目真的需要这个功能吗？
**答案**：**必要**

**业务价值**：
- 多轮对话是工作流的核心功能
- 知识库问答需要上下文记忆
- 用户体验直接受影响

**技术价值**：
- 数据准确性：保存正确的用户输入
- 架构一致性：符合Spring AI设计理念
- 可维护性：清晰的职责分离

## 数据支撑

### 问题证据

**数据库实际内容**：
```sql
SELECT id, conversation_id, type, content
FROM ai_workflow_conversation_content
WHERE conversation_id = '20250519_001::3f8c06988595...'
ORDER BY c_time ASC
LIMIT 5;
```

**结果**：
```json
{
  "id": 1,
  "type": "user",
  "content": "【用户问题】：我是小王\n\n【分类结果】：未知请求 / 不确定\n\n【任务】：\n用户的问题不够明确..."
}
```

**日志证据**：
```
🔍 [ScmWorkflowMessageChatMemory] 查询历史记录: conversationId=..., 查询到 2 条历史
📝 [WorkflowConversationAdvisor] Stream USER消息内容长度: 487
```
- 内容长度487字符，远超"我是小王"的5个字符
- 证明保存的是完整prompt，不是原始输入

### 修复后验证

**验证点1：内容长度**
- 修复前：~487字符（包含完整模板）
- 修复后：~5字符（"我是小王"）

**验证点2：数据库内容**
```sql
-- 修复后应该看到纯粹的用户输入
SELECT content FROM ai_workflow_conversation_content
WHERE type = 'user' AND conversation_id LIKE '%::3f8c06988595%'
ORDER BY c_time DESC LIMIT 1;

-- 期望结果：
-- "我是小王"
```

**验证点3：多轮对话测试**
- 第一个问题："我是小王"
- 第二个问题："我是谁"
- 期望AI回答："你是小王"

## 风险分析与缓解措施

### 风险1：提取原始用户输入失败
**概率**：低

**影响**：降级使用完整prompt，与修复前行为一致

**缓解措施**：
- 添加详细的日志输出
- Advisor中实现降级逻辑
- 单元测试覆盖边界情况

### 风险2：参数传递链路中断
**概率**：低

**影响**：ORIGINAL_USER_INPUT为null，触发降级

**缓解措施**：
- 每个传递点都有日志记录
- 降级逻辑确保功能不中断
- 集成测试验证完整链路

### 风险3：性能影响
**概率**：极低

**影响**：遍历wfState.getInput()查找参数，时间复杂度O(n)

**缓解措施**：
- 工作流输入参数数量极少（<10个）
- 只在有conversationId时执行
- 结果可缓存（如果需要）

## 实施计划

### 阶段1：代码修改
1. 修改`WorkflowUtil.java`
   - 新增`extractOriginalUserInput()`方法
   - 修改`streamingInvokeLLM()`调用

2. 修改`AiChatBaseService.java`
   - 添加`originalUserInput`参数
   - 传递给Advisor

3. 修改`WorkflowConversationAdvisor.java`
   - 新增`ORIGINAL_USER_INPUT`常量
   - 实现优先使用逻辑

### 阶段2：测试验证
1. 单元测试
   - `extractOriginalUserInput()`边界测试
   - Advisor降级逻辑测试

2. 集成测试
   - 完整工作流执行
   - 数据库内容验证
   - 多轮对话测试

### 阶段3：QA评审
- 代码质量检查
- KISS原则验证
- 向后兼容性确认

## 总结

### 方案优势
✅ 符合Spring AI架构设计
✅ 代码清晰，职责明确
✅ 零破坏，向后兼容
✅ 易于测试和验证

### 关键设计
- 通过Advisor参数传递原始用户输入
- 从`wfState.getInput()`提取`var_user_input`
- 优先使用原始输入，降级使用prompt
- 保持与现有架构的一致性

### 预期效果
- ✅ 数据库保存纯粹的用户输入（"我是小王"）
- ✅ 多轮对话记忆功能正常工作
- ✅ AI能够正确理解对话历史上下文
