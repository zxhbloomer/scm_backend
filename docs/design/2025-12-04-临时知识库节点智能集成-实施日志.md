# 临时知识库节点智能集成 - 实施日志

## 实施时间
2025-12-04

## 实施目标
知识检索节点自动检测上游临时知识库节点，支持选择临时知识库或永久知识库

## 代码变更清单

### 后端修改

#### 1. KnowledgeRetrievalNodeConfig.java
**路径**: `scm-ai/src/main/java/com/xinyirun/scm/ai/workflow/node/knowledgeretrieval/KnowledgeRetrievalNodeConfig.java`

**新增字段**:
```java
@JsonProperty("is_temp_kb")
private Boolean isTempKb;  // 是否使用临时知识库

@JsonProperty("temp_kb_node_uuid")
private String tempKbNodeUuid;  // 临时知识库节点UUID
```

#### 2. KnowledgeRetrievalNode.java
**路径**: `scm-ai/src/main/java/com/xinyirun/scm/ai/workflow/node/knowledgeretrieval/KnowledgeRetrievalNode.java`

**修改内容**:
```java
// 检查是否使用临时知识库
if (Boolean.TRUE.equals(nodeConfig.getIsTempKb())) {
    log.info("使用临时知识库,临时知识库节点UUID: {}, 变量引用: {}",
            nodeConfig.getTempKbNodeUuid(), kbUuid);
}

// 如果是变量引用(格式:{nodeUuid_paramName}),进行变量渲染
if (kbUuid.startsWith("{") && kbUuid.endsWith("}")) {
    String originalKbUuid = kbUuid;
    kbUuid = WorkflowUtil.renderTemplate(kbUuid, state.getInputs());
    log.info("渲染临时知识库变量引用: {} -> {}", originalKbUuid, kbUuid);

    if (StringUtils.isBlank(kbUuid)) {
        throw new BusinessException("知识库UUID不能为空(变量引用解析失败,请确保上游临时知识库节点已执行)");
    }
}
```

### 前端修改

#### 3. KnowledgeRetrievalNodeProperty.vue
**路径**: `01_scm_frontend/scm_frontend/src/components/70_ai/components/workflow/components/properties/KnowledgeRetrievalNodeProperty.vue`

**完整重构**: 移除WfKnowledgeSelector依赖，使用原生el-select + el-option-group

**核心变更**:

1. **data新增**:
```javascript
upstreamTempKbNodes: [],      // 上游临时知识库节点列表
permanentKbs: [],             // 永久知识库列表
selectedKbSource: ''          // 当前选择(格式: permanent_{uuid} 或 temp_{nodeUuid})
```

2. **mounted增加**:
```javascript
this.detectUpstreamTempKbNodes()  // 检测上游临时知识库节点
this.loadPermanentKnowledgeBases()  // 加载永久知识库
this.initializeSelection()        // 初始化当前选择
this.watchGraphChanges()          // 监听X6 graph事件
```

3. **核心方法**:
```javascript
// 检测上游临时知识库节点
detectUpstreamTempKbNodes() {
  const incomingEdges = graph.getIncomingEdges(currentNodeId)
  incomingEdges.forEach(edge => {
    const sourceNode = graph.getCell(edge.source.cell)
    if (sourceNode.data.wfComponent.name === 'TempKnowledgeBase') {
      tempKbNodes.push(sourceNode.data)
    }
  })
}

// 监听X6 graph事件
watchGraphChanges() {
  graph.on('cell:removed', ({ cell }) => {
    if (cell.isEdge && cell.target.cell === this.wfNode.uuid) {
      this.detectUpstreamTempKbNodes()
      this.validateTempKbSelection()
    }
  })
}

// 处理临时知识库选择
handleTempKbSelected(tempKbNodeUuid) {
  const variableRef = `{${tempKbNodeUuid}_kbUuid}`
  this.nodeConfig.knowledge_base_uuid = variableRef
  this.nodeConfig.is_temp_kb = true
  this.nodeConfig.temp_kb_node_uuid = tempKbNodeUuid
}
```

4. **UI模板**:
```vue
<el-select v-model="selectedKbSource">
  <!-- 永久知识库选项组 -->
  <el-option-group label="永久知识库">
    <el-option
      v-for="kb in permanentKbs"
      :key="kb.value"
      :value="`permanent_${kb.value}`"
    />
  </el-option-group>

  <!-- 临时知识库选项组(仅在有上游临时知识库节点时显示) -->
  <el-option-group
    v-if="upstreamTempKbNodes.length > 0"
    label="临时知识库(上游节点)"
  >
    <el-option
      v-for="node in upstreamTempKbNodes"
      :key="node.uuid"
      :value="`temp_${node.uuid}`"
    />
  </el-option-group>
</el-select>
```

## 核心机制

### 变量引用机制
```
前端保存: knowledge_base_uuid = "{1234567890_kbUuid}"
                                   ↓
                    临时知识库节点执行,输出kbUuid
                                   ↓
            state.getInputs()["1234567890_kbUuid"] = "scm_tenant...::uuid"
                                   ↓
        知识检索节点执行,调用WorkflowUtil.renderTemplate()
                                   ↓
            解析结果: "scm_tenant_20250519_001::abc-def-ghi-..."
                                   ↓
                      使用真实UUID进行向量检索
```

### 动态检测机制
- **mounted**: 初次打开属性面板时检测上游节点
- **cell:removed**: 监听连线删除事件,实时更新临时知识库选项
- **validateTempKbSelection**: 验证已选临时知识库是否仍存在,不存在则清除

## 向后兼容
- `is_temp_kb`默认false,老workflow不受影响
- 如果`knowledge_base_uuid`不是变量引用格式(不以`{`开头`}`结尾),直接当作永久知识库UUID使用
- 永久知识库选择流程完全保持不变

## 使用说明

### 用户操作流程
1. 在workflow画布中创建"临时知识库"节点
2. 创建"知识检索"节点
3. 从"临时知识库"节点连线到"知识检索"节点
4. 打开"知识检索"节点的属性面板
5. 在"知识库"下拉中会看到两个分组:
   - 永久知识库(列出所有可用的永久知识库)
   - 临时知识库(上游节点)(列出所有上游的临时知识库节点)
6. 选择临时知识库后,会自动设置变量引用
7. workflow执行时,变量引用会被解析为实际的临时知识库UUID

### 前端重新编译
修改完成后,需要重新编译前端:
```bash
cd 01_scm_frontend/scm_frontend
npm run dev  # 开发模式
# 或
npm run build:stage  # 构建模式
```

### 验证方式
1. 浏览器打开workflow设计器
2. 创建临时知识库节点 → 知识检索节点
3. 连线后打开知识检索节点属性
4. 确认"知识库"字段是el-select下拉选择器(不是输入框)
5. 确认下拉中有两个分组
6. 选择临时知识库,保存workflow
7. 执行workflow,查看后端日志确认变量引用解析成功

## Git提交信息模板
```
feat(workflow): 知识检索节点支持临时知识库智能集成

- 后端: 新增is_temp_kb和temp_kb_node_uuid配置字段
- 后端: 支持变量引用格式{nodeUuid_kbUuid}的解析
- 前端: 重构知识库选择器,使用el-select分组显示
- 前端: 实现X6 graph事件监听,动态检测上游临时知识库节点
- 前端: 实现连线删除时自动清除已选临时知识库

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

## 相关设计文档
- [2025-12-04-143000-临时知识库节点智能集成-方案.md](./2025-12-04-143000-临时知识库节点智能集成-方案.md)
