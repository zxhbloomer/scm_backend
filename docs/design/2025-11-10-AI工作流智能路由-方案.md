# AI工作流智能路由实现方案

**文档版本**: v2.0 (合并版)
**创建日期**: 2025-11-10
**设计者**: zzxxhh (Linus思维模式)
**项目**: scm-ai 智能工作流路由系统

---

## 一、需求背景

### 1.1 业务场景

scm-ai 系统当前已实现多个AI工作流:
- `14c91cd41e44490f885983703d53a31e`: SCM智能助手-v1
- `3f8c0698859542cba91a481607a2fcf1`: 知识库问答-v1
- `1746fd485e6c47c59f8b8e14e7bd7728`: chat流程入口-v1

**现状问题**:
用户发起对话时,必须手动选择工作流或前端传入 `workflowId`,导致:
- ❌ 用户体验差:每次对话都要先选择"助手类型"
- ❌ 前端复杂度高:需要维护工作流选择逻辑
- ❌ 不符合产品定位:"智能助手"应该自动理解意图,而非"工具选择器"

### 1.2 核心需求

**用一句话说清楚**:
> 用户输入一句话,系统自动从数据库的多个工作流中选择最合适的一个执行,并返回流式响应。

**举例**:
```
用户输入: "帮我查一下订单PO20250109001的状态"

系统自动:
1. 识别意图 → SCM业务查询
2. 路由选择 → "SCM智能助手-v1" 工作流
3. 执行返回 → "订单状态:已发货,预计1月12日送达"

用户无需选择任何工作流
```

### 1.3 技术目标

- ✅ **准确率**: 90%+ 的路由准确率
- ✅ **性能**: P50延迟 < 50ms, P95延迟 < 2s
- ✅ **稳定性**: LLM失败时自动降级,永不返回错误
- ✅ **向后兼容**: 现有 `workflowId` 参数继续有效
- ✅ **多租户隔离**: 租户间工作流完全隔离
- ✅ **权限控制**: 个人/公开工作流的可见性控制

---

## 二、核心设计思路 (Linus式分析)

### 2.1 数据结构分析 (第一层)

**核心问题**: "数据怎么组织,才能让路由逻辑最简洁?"

**数据关系图**:
```
ai_workflow (数据库)
├── workflow_uuid (主键)
├── title (工作流名称)
├── description (详细描述,供LLM理解)
├── keywords (关键词,逗号分隔,供快速匹配)
├── is_enable (发布状态: true=已发布, false=草稿)
├── is_public (可见范围: true=公开, false=个人)
├── c_id (创建人ID)
├── category (分类: 0=业务处理,1=知识问答,2=通用对话,仅用于UI筛选)
└── priority (优先级 0-100)

运行时内存:
Map<String, WorkflowInfo> routeCache
├── key: workflowId
└── value: {title, description, keywords, priority}

路由决策:
用户输入 → 关键词匹配(O(n)) → workflowId
         ↓ 未命中
         LLM路由(~1.5s) → workflowId
         ↓ 失败
         兜底工作流 → workflowId (永不为null)
```

**数据流向**:
1. **启动时**: DB → 加载到内存缓存
2. **路由时**: 用户输入 → 匹配算法 → workflowId
3. **执行时**: workflowId → WorkflowStarter.streaming() → Flux<String>

### 2.2 特殊情况消除 (第二层)

**原则**: 好代码没有特殊情况 (Linus核心哲学)

**设计方案**: 使用责任链模式,每一层要么处理,要么传递

```java
// 伪代码:展示思路
public Flux<String> route(String input, String workflowId) {
    // 责任链: Layer1 → Layer2 → Layer3 → Layer4
    return Optional.ofNullable(workflowId)
        .map(id -> executeWorkflow(id))              // Layer 1
        .orElseGet(() -> matchByKeywords(input)
            .map(this::executeWorkflow)              // Layer 2
            .orElseGet(() -> routeByLLM(input)
                .map(this::executeWorkflow)          // Layer 3
                .orElseGet(() -> fallbackWorkflow()) // Layer 4 (兜底)
            )
        );
}
```

**消除的特殊情况**:
- ❌ `if (workflowId == null) {...}`
- ❌ `if (keywordMatch == null) {...}`
- ❌ `if (llmRouting failed) throw Exception`
- ✅ 使用 Optional 链式调用,每层失败自动进入下一层

### 2.3 复杂度控制 (第三层)

**问题**: 这个功能用了多少概念?

**概念清单**:
1. Spring AI ChatClient (LLM调用)
2. RoutingWorkflow (路由决策)
3. 关键词匹配 (快速路由)
4. 数据库查询 (工作流加载)
5. WorkflowStarter (工作流执行)
6. Reactor Flux (流式响应)

**总计**: 6个核心概念

**简化方案**: 将1、2、3统一抽象为 `WorkflowRouter`

```java
// 简化后:只有4个核心概念
@Service
public class WorkflowRoutingService {
    @Autowired private WorkflowRouter router;        // 统一路由器
    @Autowired private WorkflowStarter starter;      // 工作流执行
    @Autowired private AiWorkflowService dbService;  // 数据库服务

    public Flux<String> chat(String input, String workflowId) {
        String selectedId = router.route(input, workflowId);
        return starter.streaming(selectedId, params);
    }
}
```

### 2.4 破坏性分析 (第四层)

**问题**: 会破坏现有功能吗?

**影响分析**:

| 现有组件 | 是否受影响 | 兼容性方案 |
|---------|-----------|-----------|
| WorkflowStarter | ✅ 无影响 | 接口不变,只是增加了路由层 |
| AiChatService | ✅ 无影响 | 简单聊天仍走原逻辑 |
| 前端调用 | ⚠️ 微小影响 | workflowId变为可选参数,向后兼容 |
| 数据库 | ⚠️ 需增加字段 | 新增5个字段,不影响现有数据 |

**向后兼容保证**:
```java
// 老代码: 前端传workflowId
chat(input, workflowId="14c91cd4...")  → 直接执行,0ms延迟

// 新代码: 前端不传workflowId
chat(input, workflowId=null)           → 自动路由,10ms~2s延迟
```

### 2.5 实用性验证 (第五层)

**问题1**: 这是真问题还是臆想?
✅ **真问题**:
- 数据库已有3+个工作流
- 用户每次对话都要选择
- 高频操作,不是边缘场景

**问题2**: 解决方案的复杂度与问题严重性匹配吗?
✅ **完全匹配**:
- 问题严重性: **中高** (影响所有用户体验)
- 解决方案: **中等** (~500行代码,4个核心概念)
- ROI: **非常高** (大幅提升用户体验,代码量可控)

**问题3**: 有更简单的方法吗?
✅ **已是最简**:
- 去掉关键词层? → 性能差 (每次调LLM 1-2s)
- 去掉LLM层? → 准确率低 (关键词无法理解语义)
- 当前方案是性能和准确率的最佳平衡

---

## 三、技术方案设计

### 3.1 整体架构图

```
┌──────────────────────────────────────────────────────┐
│                   前端 (Vue.js)                       │
│  - 用户输入框                                         │
│  - 工作流管理页面 (新增发布按钮)                      │
└────────────────┬─────────────────────────────────────┘
                 │ HTTP /ai/chat?workflowId=xxx (可选)
                 ▼
┌──────────────────────────────────────────────────────┐
│          AiChatController (REST层)                    │
│  - chat(userInput, workflowId?, tenantCode, userId)  │
└────────────────┬─────────────────────────────────────┘
                 │
                 ▼
┌──────────────────────────────────────────────────────┐
│      WorkflowRoutingService (路由服务层)             │
│                                                       │
│  ┌─────────────────────────────────────────┐        │
│  │ Layer 1: 用户指定 (0ms)                  │        │
│  │   if (workflowId != null)               │        │
│  │     return executeWorkflow(workflowId)  │        │
│  └─────────────────────────────────────────┘        │
│                 ↓ workflowId = null                  │
│  ┌─────────────────────────────────────────┐        │
│  │ Layer 2: 关键词匹配 (10ms)               │        │
│  │   keywords.contains(input)              │        │
│  │   命中率: 70-80%                         │        │
│  └─────────────────────────────────────────┘        │
│                 ↓ 未命中                             │
│  ┌─────────────────────────────────────────┐        │
│  │ Layer 3: LLM智能路由 (1-2s)              │        │
│  │   Spring AI RoutingWorkflow             │        │
│  │   ChatClient.entity(RoutingResponse)    │        │
│  │   命中率: 95%+                           │        │
│  └─────────────────────────────────────────┘        │
│                 ↓ 失败或超时                         │
│  ┌─────────────────────────────────────────┐        │
│  │ Layer 4: 兜底策略 (10ms)                 │        │
│  │   defaultWorkflowId (永不失败)          │        │
│  └─────────────────────────────────────────┘        │
│                                                       │
└────────────────┬─────────────────────────────────────┘
                 │ workflowId
                 ▼
┌──────────────────────────────────────────────────────┐
│      WorkflowStarter (工作流执行层)                   │
│  - streaming(workflowId, params)                     │
│  - 返回 Flux<String>                                 │
└────────────────┬─────────────────────────────────────┘
                 │
                 ▼
┌──────────────────────────────────────────────────────┐
│              前端 (流式渲染)                          │
│  - 逐字显示AI回复                                     │
└──────────────────────────────────────────────────────┘
```

### 3.2 数据库Schema设计

#### 3.2.1 ai_workflow 表结构调整

```sql
-- 新增字段 (5个,已简化:移除example_inputs)
ALTER TABLE ai_workflow
-- 1. 测试时间 (辅助字段,控制发布按钮)
ADD COLUMN last_test_time DATETIME
COMMENT '最后测试运行时间,用于判断是否可发布',

-- 2. 详细描述 (供LLM理解)
ADD COLUMN description TEXT
COMMENT '工作流详细描述,说明适用场景、功能、输入输出等,供AI路由使用',

-- 3. 关键词 (供程序快速匹配, 逗号分隔)
ADD COLUMN keywords VARCHAR(500) DEFAULT ''
COMMENT '关键词,逗号分隔,用于快速匹配,如: 订单,采购,库存,入库,出库',

-- 4. 分类标签(字典值)
ADD COLUMN category VARCHAR(10) DEFAULT '0'
COMMENT '工作流分类(字典:ai_workflow_category): 0=业务处理, 1=知识问答, 2=通用对话',

-- 5. 优先级
ADD COLUMN priority INT DEFAULT 50
COMMENT '优先级(0-100),越高越优先,用于多个工作流匹配时的排序';

-- 索引优化
CREATE INDEX idx_workflow_tenant_enable ON ai_workflow(tenant_code, is_enable);
CREATE INDEX idx_workflow_priority ON ai_workflow(priority);

-- 可选: keywords全文索引(如需高效关键词搜索)
-- CREATE FULLTEXT INDEX idx_workflow_keywords ON ai_workflow(keywords);
```

#### 3.2.2 字段语义重新定义

| 字段 | 类型 | 新语义 | 说明 |
|------|------|--------|------|
| `is_enable` | BOOLEAN | **已发布/未发布** | true=已发布(生产可用), false=草稿(仅创建者可见) |
| `is_public` | BOOLEAN | 公开/个人 | true=所有人可见, false=仅创建者可见 |
| `last_test_time` | DATETIME | 最后测试时间 | 用于判断是否可发布 (测试时间 > 更新时间) |
| `description` | TEXT | 详细描述 | 供LLM理解适用场景,用于Layer 3路由决策 |
| `keywords` | VARCHAR(500) | 关键词 | 逗号分隔,供Layer 2快速匹配,格式: `订单,采购,库存` |
| `category` | VARCHAR(10) | 分类标签 | 字典值: `'0'`=业务处理, `'1'`=知识问答, `'2'`=通用对话,**仅用于UI筛选** |
| `priority` | INT | 优先级 | 0-100,越高越优先,多个匹配时排序用 |

#### 3.2.3 示例数据

```sql
-- SCM智能助手
INSERT INTO ai_workflow (
    workflow_uuid, title, description, keywords, category, priority,
    is_enable, is_public, tenant_code, c_id, c_time, u_time
) VALUES (
    '14c91cd41e44490f885983703d53a31e',
    'SCM智能助手',
    '专门处理供应链管理相关问题,包括:
     - 订单查询: 采购订单、销售订单状态查询
     - 库存管理: 入库、出库、库存余额查询
     - 采购流程: 采购申请、采购单审批、供应商管理
     - 物流追踪: 发货状态、物流信息查询

     适用场景: 用户询问具体的SCM业务操作或数据查询
     不适用: 通用知识问答、闲聊',
    '订单,采购,库存,入库,出库,发货,收货,供应商,采购单,销售单,库存余额,物流,审批,采购申请',
    '0',  -- 业务处理
    80,
    TRUE,  -- 已发布
    TRUE,  -- 公开
    'tenant_001',
    1001,
    NOW(),
    NOW()
);

-- 知识库问答
INSERT INTO ai_workflow (
    workflow_uuid, title, description, keywords, category, priority,
    is_enable, is_public, tenant_code, c_id, c_time, u_time
) VALUES (
    '3f8c0698859542cba91a481607a2fcf1',
    '知识库问答',
    '从知识库中检索相关文档和FAQ,回答用户的知识性问题。

     适用场景: 产品使用说明、操作指南、常见问题
     不适用: 实时数据查询、业务操作',
    '怎么用,如何操作,使用说明,帮助文档,教程,指南,怎么做,步骤',
    '1',  -- 知识问答
    50,
    TRUE,
    TRUE,
    'tenant_001',
    1001,
    NOW(),
    NOW()
);
```

### 3.3 后端实现设计

#### 3.3.1 Entity层

```java
package com.xinyirun.scm.ai.bean.entity;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@TableName("ai_workflow")
public class AiWorkflowEntity {

    @TableId(type = IdType.AUTO)
    private Long id;

    @TableField("workflow_uuid")
    private String workflow_uuid;

    @TableField("title")
    private String title;

    @TableField("remark")
    private String remark;

    // ========== 新增字段 ==========

    /**
     * 详细描述,供LLM理解适用场景
     */
    @TableField("description")
    private String description;

    /**
     * 关键词,逗号分隔
     * 示例: "订单,采购,库存,入库,出库"
     */
    @TableField("keywords")
    private String keywords;

    /**
     * 工作流分类(字典值: ai_workflow_category)
     * 取值: 0=业务处理, 1=知识问答, 2=通用对话
     *
     * 注意: 仅用于前端UI筛选,不参与路由逻辑
     */
    @TableField("category")
    private String category;

    /**
     * 优先级 (0-100)
     */
    @TableField("priority")
    private Integer priority;

    /**
     * 最后测试运行时间
     */
    @TableField("last_test_time")
    private LocalDateTime last_test_time;

    // ========== 原有字段 ==========

    /**
     * 是否启用 (复用为发布状态)
     * true = 已发布 (生产可用)
     * false = 未发布/草稿 (仅创建者可见)
     */
    @TableField("is_enable")
    private Boolean is_enable;

    /**
     * 是否公开
     */
    @TableField("is_public")
    private Boolean is_public;

    @TableField("tenant_code")
    private String tenant_code;

    @TableField(value = "c_id", fill = FieldFill.INSERT)
    private Long c_id;

    @TableField(value = "c_time", fill = FieldFill.INSERT)
    private LocalDateTime c_time;

    @TableField(value = "u_id", fill = FieldFill.INSERT_UPDATE)
    private Long u_id;

    @TableField(value = "u_time", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime u_time;

    @Version
    @TableField("dbversion")
    private Integer dbversion;

    // ========== 辅助方法 ==========

    /**
     * 获取关键词数组
     */
    public String[] getKeywordsArray() {
        if (keywords == null || keywords.isEmpty()) {
            return new String[0];
        }
        return keywords.split(",");
    }

    /**
     * 设置关键词数组
     */
    public void setKeywordsArray(String[] keywordsArray) {
        this.keywords = String.join(",", keywordsArray);
    }
}
```

#### 3.3.2 Mapper层

```java
package com.xinyirun.scm.ai.core.mapper.workflow;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.xinyirun.scm.ai.bean.entity.AiWorkflowEntity;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Select;
import java.util.List;

@Mapper
public interface AiWorkflowMapper extends BaseMapper<AiWorkflowEntity> {

    /**
     * 查询用户可用的工作流 (用于路由)
     *
     * 规则:
     * 1. 租户隔离: tenant_code
     * 2. 已发布: is_enable = 1
     * 3. 可见性: is_public = 1 OR c_id = userId
     * 4. 排序: 个人优先 > 优先级高 > 最新更新
     */
    @Select("""
        SELECT * FROM ai_workflow
        WHERE tenant_code = #{tenantCode}
          AND is_enable = 1
          AND (is_public = 1 OR c_id = #{userId})
        ORDER BY
          CASE WHEN c_id = #{userId} THEN 0 ELSE 1 END,
          priority DESC,
          u_time DESC
        """)
    List<AiWorkflowEntity> selectAvailableWorkflows(
        @Param("tenantCode") String tenantCode,
        @Param("userId") Long userId
    );

    /**
     * 查询用户所有工作流 (包括未发布的,用于管理页面)
     */
    @Select("""
        SELECT * FROM ai_workflow
        WHERE tenant_code = #{tenantCode}
          AND (is_public = 1 OR c_id = #{userId})
        ORDER BY u_time DESC
        """)
    List<AiWorkflowEntity> selectAllUserWorkflows(
        @Param("tenantCode") String tenantCode,
        @Param("userId") Long userId
    );

    /**
     * 查询默认工作流 (兜底策略)
     */
    @Select("""
        SELECT * FROM ai_workflow
        WHERE tenant_code = #{tenantCode}
          AND is_enable = 1
          AND is_public = 1
        ORDER BY priority DESC
        LIMIT 1
        """)
    AiWorkflowEntity selectDefaultWorkflow(@Param("tenantCode") String tenantCode);

    /**
     * 前端Tab筛选查询(可选按category筛选)
     */
    @Select("""
        SELECT * FROM ai_workflow
        WHERE tenant_code = #{tenantCode}
          AND is_enable = 1
          AND (is_public = 1 OR c_id = #{userId})
          AND (#{category} IS NULL OR category = #{category})
        ORDER BY priority DESC, u_time DESC
        """)
    List<AiWorkflowEntity> selectPublishedWorkflows(
        @Param("tenantCode") String tenantCode,
        @Param("userId") Long userId,
        @Param("category") String category  // '0'/'1'/'2'/null
    );
}
```

#### 3.3.3 Service层

```java
package com.xinyirun.scm.ai.core.service.workflow;

import com.xinyirun.scm.ai.bean.entity.AiWorkflowEntity;
import com.xinyirun.scm.ai.core.mapper.workflow.AiWorkflowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.List;

@Service
public class AiWorkflowService {

    @Autowired
    private AiWorkflowMapper workflowMapper;

    /**
     * 查询用户可用的工作流 (用于路由)
     */
    public List<AiWorkflowEntity> getAvailableWorkflows(String tenantCode, Long userId) {
        return workflowMapper.selectAvailableWorkflows(tenantCode, userId);
    }

    /**
     * 查询用户所有工作流 (用于管理页面)
     */
    public List<AiWorkflowEntity> getAllUserWorkflows(String tenantCode, Long userId) {
        return workflowMapper.selectAllUserWorkflows(tenantCode, userId);
    }

    /**
     * 查询默认工作流
     */
    public AiWorkflowEntity getDefaultWorkflow(String tenantCode) {
        return workflowMapper.selectDefaultWorkflow(tenantCode);
    }

    /**
     * 保存工作流
     * 如果当前是已发布状态,强制改为未发布
     */
    public void save(AiWorkflowEntity workflow) {
        if (workflow.getIs_enable() != null && workflow.getIs_enable()) {
            workflow.setIs_enable(false);
        }

        if (workflow.getId() == null) {
            workflowMapper.insert(workflow);
        } else {
            workflowMapper.updateById(workflow);
        }
    }

    /**
     * 更新测试运行时间
     */
    public void updateTestTime(String workflowId) {
        AiWorkflowEntity workflow = workflowMapper.selectById(workflowId);
        workflow.setLast_test_time(LocalDateTime.now());
        workflowMapper.updateById(workflow);
    }

    /**
     * 发布工作流
     */
    public void publish(String workflowId) {
        AiWorkflowEntity workflow = workflowMapper.selectById(workflowId);

        // 校验: 是否测试过
        if (workflow.getLast_test_time() == null) {
            throw new BusinessException("请先执行测试运行,确认工作流正常后再发布");
        }

        // 校验: 测试时间是否在更新时间之后
        if (workflow.getLast_test_time().isBefore(workflow.getU_time())) {
            throw new BusinessException("工作流已修改,请重新测试运行后再发布");
        }

        // 发布
        workflow.setIs_enable(true);
        workflowMapper.updateById(workflow);
    }

    /**
     * 取消发布
     */
    public void unpublish(String workflowId) {
        AiWorkflowEntity workflow = workflowMapper.selectById(workflowId);
        workflow.setIs_enable(false);
        workflowMapper.updateById(workflow);
    }
}
```

#### 3.3.4 路由服务层 (核心)

**文件**: `WorkflowRoutingService.java`

```java
package com.xinyirun.scm.ai.core.service.routing;

import com.xinyirun.scm.ai.bean.entity.AiWorkflowEntity;
import com.xinyirun.scm.ai.bean.vo.workflow.RoutingResponseVo;
import com.xinyirun.scm.ai.core.service.workflow.AiWorkflowService;
import com.xinyirun.scm.ai.core.service.workflow.WorkflowStarter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Service
public class WorkflowRoutingService {

    @Autowired
    private ChatClient chatClient;

    @Autowired
    private WorkflowStarter workflowStarter;

    @Autowired
    private AiWorkflowService workflowService;

    /**
     * 智能路由并执行工作流
     *
     * @param userInput 用户输入
     * @param tenantCode 租户编码
     * @param userId 当前用户ID
     * @param workflowId 指定的工作流ID (可选)
     * @return 流式响应
     */
    public Flux<String> chat(String userInput,
                              String tenantCode,
                              Long userId,
                              String workflowId) {

        // Layer 1: 用户指定 (0ms)
        if (workflowId != null) {
            log.info("Layer 1 - 用户指定工作流: {}", workflowId);

            // 检查权限
            if (!hasAccessPermission(workflowId, tenantCode, userId)) {
                return Flux.error(new BusinessException("无权访问该工作流"));
            }

            return executeWorkflow(workflowId, userInput, tenantCode);
        }

        // Layer 2: 关键词快速匹配 (10ms)
        String matchedId = matchByKeywords(userInput, tenantCode, userId);
        if (matchedId != null) {
            log.info("Layer 2 - 关键词匹配命中: {}", matchedId);
            return executeWorkflow(matchedId, userInput, tenantCode);
        }

        // Layer 3: LLM智能路由 (1-2s)
        try {
            String routedId = routeByLLM(userInput, tenantCode, userId);
            if (routedId != null) {
                log.info("Layer 3 - LLM路由命中: {}", routedId);
                return executeWorkflow(routedId, userInput, tenantCode);
            }
        } catch (Exception e) {
            log.error("Layer 3 - LLM路由失败,进入兜底: {}", e.getMessage());
        }

        // Layer 4: 兜底策略 (10ms)
        log.info("Layer 4 - 使用默认工作流");
        return fallbackWorkflow(userInput, tenantCode);
    }

    /**
     * Layer 2: 关键词快速匹配
     */
    private String matchByKeywords(String input, String tenantCode, Long userId) {
        List<AiWorkflowEntity> workflows = workflowService.getAvailableWorkflows(tenantCode, userId);

        return workflows.stream()
            .filter(w -> w.getKeywords() != null && !w.getKeywords().isEmpty())
            .filter(w -> containsAnyKeyword(input, w.getKeywords()))
            .max((w1, w2) -> Integer.compare(
                w1.getPriority() != null ? w1.getPriority() : 50,
                w2.getPriority() != null ? w2.getPriority() : 50
            ))
            .map(AiWorkflowEntity::getWorkflow_uuid)
            .orElse(null);
    }

    /**
     * 检查输入是否包含任一关键词
     */
    private boolean containsAnyKeyword(String input, String keywords) {
        String[] keywordArray = keywords.split(",");
        for (String keyword : keywordArray) {
            if (input.contains(keyword.trim())) {
                return true;
            }
        }
        return false;
    }

    /**
     * Layer 3: LLM智能路由
     */
    private String routeByLLM(String input, String tenantCode, Long userId) {
        List<AiWorkflowEntity> workflows = workflowService.getAvailableWorkflows(tenantCode, userId);

        if (workflows.isEmpty()) {
            return null;
        }

        // 构建路由表: workflowId → description
        Map<String, String> routes = workflows.stream()
            .collect(Collectors.toMap(
                AiWorkflowEntity::getWorkflow_uuid,
                w -> String.format("[%s] %s: %s",
                    w.getC_id().equals(userId) ? "个人" : "公开",
                    w.getTitle(),
                    w.getDescription() != null ? w.getDescription() : w.getRemark()
                )
            ));

        // 构建路由Prompt
        String prompt = buildRoutingPrompt(input, routes);

        // 调用LLM
        RoutingResponseVo response = chatClient.prompt(prompt)
            .call()
            .entity(RoutingResponseVo.class);

        log.info("LLM路由决策 - 推理: {}, 选择: {}",
            response.reasoning(), response.selection());

        return response.selection();
    }

    /**
     * 构建LLM路由Prompt
     */
    private String buildRoutingPrompt(String input, Map<String, String> routes) {
        String routesDescription = routes.entrySet().stream()
            .map(e -> String.format("  - ID: %s\n    描述: %s", e.getKey(), e.getValue()))
            .collect(Collectors.joining("\n"));

        return String.format("""
            请分析用户输入,从以下工作流中选择最合适的一个:

            可选工作流:
            %s

            选择标准:
            1. 优先匹配描述中明确说明"适用场景"的工作流
            2. 考虑用户意图与工作流功能的匹配度
            3. 如果多个匹配,选择更专业的工作流

            返回JSON格式:
            {
                "reasoning": "选择理由(中文,50字以内)",
                "selection": "工作流ID"
            }

            用户输入: %s
            """, routesDescription, input);
    }

    /**
     * Layer 4: 兜底策略
     */
    private Flux<String> fallbackWorkflow(String input, String tenantCode) {
        AiWorkflowEntity defaultWorkflow = workflowService.getDefaultWorkflow(tenantCode);

        if (defaultWorkflow == null) {
            return Flux.error(new BusinessException("未找到可用的工作流"));
        }

        return executeWorkflow(defaultWorkflow.getWorkflow_uuid(), input, tenantCode);
    }

    /**
     * 执行工作流
     */
    private Flux<String> executeWorkflow(String workflowId, String input, String tenantCode) {
        Map<String, Object> params = Map.of(
            "userInput", input,
            "tenantCode", tenantCode
        );

        return workflowStarter.streaming(workflowId, params);
    }

    /**
     * 检查用户是否有权限访问工作流
     */
    private boolean hasAccessPermission(String workflowId, String tenantCode, Long userId) {
        // 实现省略,参考前文
        return true;
    }
}
```

#### 3.3.5 VO类

```java
package com.xinyirun.scm.ai.bean.vo.workflow;

/**
 * LLM路由决策响应
 *
 * @param reasoning 推理过程
 * @param selection 选中的工作流ID
 */
public record RoutingResponseVo(String reasoning, String selection) {
}
```

#### 3.3.6 Controller层

```java
package com.xinyirun.scm.ai.controller.workflow;

import com.xinyirun.scm.ai.core.service.routing.WorkflowRoutingService;
import com.xinyirun.scm.ai.core.service.workflow.AiWorkflowService;
import com.xinyirun.scm.common.bean.ResponseVo;
import com.xinyirun.scm.security.util.SecurityUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;

@RestController
@RequestMapping("/ai/chat")
public class AiChatController {

    @Autowired
    private WorkflowRoutingService routingService;

    @Autowired
    private AiWorkflowService workflowService;

    /**
     * 智能对话接口
     *
     * @param userInput 用户输入
     * @param workflowId 指定的工作流ID (可选)
     * @return 流式响应
     */
    @PostMapping("/stream")
    public Flux<String> chat(
        @RequestParam String userInput,
        @RequestParam(required = false) String workflowId
    ) {
        String tenantCode = SecurityUtil.getTenantCode();
        Long userId = SecurityUtil.getStaff_id();

        return routingService.chat(userInput, tenantCode, userId, workflowId);
    }
}

@RestController
@RequestMapping("/ai/workflow")
public class AiWorkflowController {

    @Autowired
    private AiWorkflowService workflowService;

    /**
     * 保存工作流
     */
    @PostMapping("/save")
    public ResponseVo save(@RequestBody AiWorkflowEntity workflow) {
        workflowService.save(workflow);
        return ResponseVo.success();
    }

    /**
     * 更新测试时间
     */
    @PostMapping("/updateTestTime/{workflowId}")
    public ResponseVo updateTestTime(@PathVariable String workflowId) {
        workflowService.updateTestTime(workflowId);
        return ResponseVo.success();
    }

    /**
     * 发布工作流
     */
    @PostMapping("/publish/{workflowId}")
    public ResponseVo publish(@PathVariable String workflowId) {
        workflowService.publish(workflowId);
        return ResponseVo.success("发布成功");
    }

    /**
     * 取消发布
     */
    @PostMapping("/unpublish/{workflowId}")
    public ResponseVo unpublish(@PathVariable String workflowId) {
        workflowService.unpublish(workflowId);
        return ResponseVo.success("已取消发布");
    }
}
```

---

## 四、前端实现设计

### 4.1 API定义

**文件路径**: `src/components/70_ai/api/workflow.js`

```javascript
import request from '@/utils/request'

/**
 * 智能对话 (流式)
 */
export function chatStream(userInput, workflowId) {
  return request({
    url: '/ai/chat/stream',
    method: 'post',
    params: { userInput, workflowId }
  })
}

/**
 * 保存工作流
 */
export function saveWorkflow(workflow) {
  return request({
    url: '/ai/workflow/save',
    method: 'post',
    data: workflow
  })
}

/**
 * 更新测试时间
 */
export function updateTestTime(workflowId) {
  return request({
    url: `/ai/workflow/updateTestTime/${workflowId}`,
    method: 'post'
  })
}

/**
 * 发布工作流
 */
export function publishWorkflow(workflowId) {
  return request({
    url: `/ai/workflow/publish/${workflowId}`,
    method: 'post'
  })
}

/**
 * 取消发布
 */
export function unpublishWorkflow(workflowId) {
  return request({
    url: `/ai/workflow/unpublish/${workflowId}`,
    method: 'post'
  })
}
```

### 4.2 工作流编辑器 (完整版)

**文件路径**: `src/components/70_ai/components/workflow/WorkflowEditor.vue`

这是工作流管理的核心页面,包含:
- 导航栏状态显示 (已发布/未发布)
- 基本信息编辑
- 流程配置
- 执行测试页签 (运行+发布按钮)

```vue
<template>
  <div class="workflow-editor">

    <!-- 导航栏 - 显示发布状态 -->
    <div class="workflow-header">
      <div class="header-left">
        <h2>{{ workflow.title || '新建工作流' }}</h2>

        <!-- 公开/个人标签 -->
        <el-tag
          :type="workflow.is_public ? 'success' : 'info'"
          size="small"
          style="margin-left: 10px"
        >
          {{ workflow.is_public ? '公开' : '个人' }}
        </el-tag>

        <!-- 发布状态标签 - 显示在"公开"旁边 -->
        <el-tag
          :type="getPublishStatusType()"
          size="small"
          style="margin-left: 10px"
        >
          {{ workflow.is_enable ? '已发布' : '未发布' }}
        </el-tag>
      </div>

      <div class="header-right">
        <el-button @click="handleSave">保存</el-button>
        <el-button type="primary" @click="handleClose">关闭</el-button>
      </div>
    </div>

    <!-- Tab页签 -->
    <el-tabs v-model="activeTab" type="border-card">

      <!-- 基本信息 -->
      <el-tab-pane label="基本信息" name="basic">
        <el-form :model="workflow" :rules="rules" label-width="120px" ref="workflowForm">

          <el-form-item label="工作流名称" prop="title">
            <el-input v-model="workflow.title" placeholder="请输入工作流名称" />
          </el-form-item>

          <el-form-item label="工作流分类" prop="category">
            <select-dict
              v-model="workflow.category"
              :para="CONSTANTS.DICT_AI_WORKFLOW_CATEGORY"
              init-placeholder="请选择工作流分类"
            />
          </el-form-item>

          <el-form-item label="是否公开" prop="is_public">
            <el-switch
              v-model="workflow.is_public"
              active-text="公开"
              inactive-text="个人"
            />
          </el-form-item>

          <el-form-item label="优先级" prop="priority">
            <el-slider
              v-model="workflow.priority"
              :min="0"
              :max="100"
              :step="10"
              show-stops
              show-input
            />
            <span class="form-tip">优先级越高,路由时越优先匹配 (0-100)</span>
          </el-form-item>

          <el-form-item label="详细描述" prop="description">
            <el-input
              v-model="workflow.description"
              type="textarea"
              :rows="6"
              placeholder="请详细描述工作流的适用场景、功能、输入输出等,供AI路由判断使用"
            />
            <span class="form-tip">
              示例: 专门处理供应链管理相关问题,包括订单查询、库存管理等。
              适用场景: 用户询问具体的SCM业务操作或数据查询。
              不适用: 通用知识问答、闲聊。
            </span>
          </el-form-item>

          <el-form-item label="关键词" prop="keywords">
            <el-input
              v-model="workflow.keywords"
              placeholder="请输入关键词,逗号分隔,如: 订单,采购,库存,入库,出库"
            />
            <span class="form-tip">关键词用于快速路由匹配,建议5-15个精准词汇</span>
          </el-form-item>

        </el-form>
      </el-tab-pane>

      <!-- 流程配置 -->
      <el-tab-pane label="流程配置" name="config">
        <!-- 这里是工作流的节点配置,省略详细实现 -->
        <div>工作流节点配置区域...</div>
      </el-tab-pane>

      <!-- 执行测试 - 核心!包含运行和发布按钮 -->
      <el-tab-pane label="执行测试" name="execute">
        <div class="execute-panel">

          <!-- 操作按钮区 -->
          <div class="action-buttons">
            <el-button
              type="primary"
              icon="el-icon-video-play"
              @click="handleTestRun"
              :loading="testRunning"
            >
              运行
            </el-button>

            <!-- 发布按钮 - 在运行按钮后面 -->
            <el-button
              type="success"
              icon="el-icon-upload2"
              @click="handlePublish"
              :disabled="!canPublish()"
              :loading="publishing"
            >
              发布
            </el-button>

            <el-button
              v-if="workflow.is_enable"
              type="warning"
              icon="el-icon-download"
              @click="handleUnpublish"
            >
              取消发布
            </el-button>

            <div class="publish-tip" v-if="!canPublish()">
              <i class="el-icon-info"></i>
              <span v-if="!workflow.last_test_time">
                请先执行测试运行,确认工作流正常后才能发布
              </span>
              <span v-else>
                工作流已修改,请重新测试运行后再发布
              </span>
            </div>
          </div>

          <!-- 测试输入区 -->
          <div class="test-input">
            <el-input
              v-model="testInput"
              type="textarea"
              :rows="3"
              placeholder="请输入测试问题,例如: 帮我查一下订单PO20250109001的状态"
            />
          </div>

          <!-- 流式输出区 -->
          <div class="test-output">
            <div class="output-header">
              <span>执行结果</span>
              <el-tag v-if="workflow.last_test_time" type="success" size="mini">
                最后测试: {{ formatTime(workflow.last_test_time) }}
              </el-tag>
            </div>
            <div class="output-content" ref="outputContent">
              <pre v-if="testOutput">{{ testOutput }}</pre>
              <div v-else class="empty-output">暂无执行结果</div>
            </div>
          </div>

        </div>
      </el-tab-pane>

    </el-tabs>

  </div>
</template>

<script>
import SelectDict from '@/components/00_dict/select/SelectDict'
import CONSTANTS from '@/common/constants/constants_dict'
import {
  saveWorkflow,
  updateTestTime,
  publishWorkflow,
  unpublishWorkflow,
  chatStream
} from '@/components/70_ai/api/workflow'

export default {
  name: 'WorkflowEditor',
  components: { SelectDict },

  data() {
    return {
      CONSTANTS,
      activeTab: 'basic',
      testRunning: false,
      publishing: false,
      testInput: '',
      testOutput: '',

      workflow: {
        workflow_uuid: '',
        title: '',
        category: '',
        is_public: true,
        is_enable: false,
        priority: 50,
        description: '',
        keywords: '',
        last_test_time: null,
        u_time: null
      },

      rules: {
        title: [{ required: true, message: '请输入工作流名称', trigger: 'blur' }],
        category: [{ required: true, message: '请选择工作流分类', trigger: 'change' }],
        description: [{ required: true, message: '请输入详细描述', trigger: 'blur' }],
        keywords: [{ required: true, message: '请输入关键词', trigger: 'blur' }]
      }
    }
  },

  methods: {
    /**
     * 判断是否可以发布
     * 条件: 1. 已测试过 2. 测试时间晚于修改时间
     */
    canPublish() {
      if (!this.workflow.last_test_time) {
        return false
      }

      if (!this.workflow.u_time) {
        return true // 新建的工作流,测试过就可以发布
      }

      return new Date(this.workflow.last_test_time) > new Date(this.workflow.u_time)
    },

    /**
     * 获取发布状态标签类型
     */
    getPublishStatusType() {
      return this.workflow.is_enable ? 'success' : 'warning'
    },

    /**
     * 保存工作流
     * 如果已发布,需要警告用户
     */
    async handleSave() {
      // 表单验证
      const valid = await this.$refs.workflowForm.validate().catch(() => false)
      if (!valid) {
        return
      }

      // 如果当前是已发布状态,弹出警告
      if (this.workflow.is_enable) {
        try {
          await this.$confirm(
            '保存工作流会强制更新发布状态为未发布,需要您测试运行该工作流没有错误后,才能发布。是否继续保存?',
            '警告',
            {
              confirmButtonText: '继续保存',
              cancelButtonText: '取消',
              type: 'warning'
            }
          )
        } catch {
          return // 用户取消
        }
      }

      // 保存
      try {
        await saveWorkflow(this.workflow)
        this.$message.success('保存成功')

        // 保存后is_enable会被后端强制设为false
        this.workflow.is_enable = false
        this.workflow.u_time = new Date()
      } catch (error) {
        this.$message.error('保存失败: ' + error.message)
      }
    },

    /**
     * 测试运行工作流
     */
    async handleTestRun() {
      if (!this.testInput) {
        this.$message.warning('请输入测试问题')
        return
      }

      this.testRunning = true
      this.testOutput = ''

      try {
        // 调用流式API
        const response = await chatStream(this.testInput, this.workflow.workflow_uuid)

        // 处理流式输出
        // 注意: 这里需要根据实际的流式响应格式来处理
        // 假设返回的是EventSource或者fetch stream
        this.testOutput = response.data

        // 测试成功,更新测试时间
        await updateTestTime(this.workflow.workflow_uuid)
        this.workflow.last_test_time = new Date()

        this.$message.success('测试运行成功')
      } catch (error) {
        this.$message.error('测试运行失败: ' + error.message)
      } finally {
        this.testRunning = false
      }
    },

    /**
     * 发布工作流
     */
    async handlePublish() {
      if (!this.canPublish()) {
        return
      }

      this.publishing = true
      try {
        await publishWorkflow(this.workflow.workflow_uuid)
        this.workflow.is_enable = true
        this.$message.success('发布成功')
      } catch (error) {
        this.$message.error('发布失败: ' + error.message)
      } finally {
        this.publishing = false
      }
    },

    /**
     * 取消发布
     */
    async handleUnpublish() {
      try {
        await this.$confirm('确认取消发布该工作流?', '提示', { type: 'warning' })
        await unpublishWorkflow(this.workflow.workflow_uuid)
        this.workflow.is_enable = false
        this.$message.success('已取消发布')
      } catch {
        // 用户取消或失败
      }
    },

    /**
     * 格式化时间
     */
    formatTime(time) {
      if (!time) return ''
      return new Date(time).toLocaleString('zh-CN')
    },

    /**
     * 关闭编辑器
     */
    handleClose() {
      this.$router.back()
    }
  }
}
</script>

<style scoped>
.workflow-editor {
  padding: 20px;
}

.workflow-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 1px solid #ebeef5;
}

.header-left {
  display: flex;
  align-items: center;
}

.form-tip {
  display: block;
  margin-top: 5px;
  font-size: 12px;
  color: #909399;
  line-height: 1.5;
}

.execute-panel {
  padding: 20px;
}

.action-buttons {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 20px;
}

.publish-tip {
  display: flex;
  align-items: center;
  gap: 5px;
  color: #e6a23c;
  font-size: 13px;
}

.test-input {
  margin-bottom: 20px;
}

.test-output {
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  overflow: hidden;
}

.output-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  background-color: #f5f7fa;
  border-bottom: 1px solid #dcdfe6;
  font-weight: bold;
}

.output-content {
  min-height: 300px;
  max-height: 500px;
  overflow-y: auto;
  padding: 15px;
  background-color: #ffffff;
}

.output-content pre {
  margin: 0;
  white-space: pre-wrap;
  word-wrap: break-word;
  font-family: 'Courier New', monospace;
  font-size: 13px;
  line-height: 1.6;
}

.empty-output {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 280px;
  color: #909399;
  font-size: 14px;
}
</style>
```

### 4.3 关键前端逻辑说明

#### 4.3.1 发布按钮启用逻辑

```javascript
canPublish() {
  // 1. 必须执行过测试运行
  if (!this.workflow.last_test_time) {
    return false
  }

  // 2. 测试时间必须晚于修改时间
  if (this.workflow.u_time) {
    return new Date(this.workflow.last_test_time) > new Date(this.workflow.u_time)
  }

  return true
}
```

**逻辑说明**:
- 新建工作流: 只要测试过就可以发布
- 已有工作流: 测试时间必须晚于最后修改时间

#### 4.3.2 保存时的警告确认

```javascript
async handleSave() {
  // 如果当前是已发布状态,必须警告
  if (this.workflow.is_enable) {
    await this.$confirm(
      '保存工作流会强制更新发布状态为未发布,需要您测试运行该工作流没有错误后,才能发布。是否继续保存?',
      '警告',
      { type: 'warning' }
    )
  }

  await saveWorkflow(this.workflow)

  // 保存后后端会强制设为未发布
  this.workflow.is_enable = false
}
```

#### 4.3.3 测试运行流程

```javascript
async handleTestRun() {
  // 1. 执行工作流
  await chatStream(this.testInput, this.workflow.workflow_uuid)

  // 2. 更新测试时间
  await updateTestTime(this.workflow.workflow_uuid)
  this.workflow.last_test_time = new Date()

  // 3. 此时发布按钮会自动启用 (因为canPublish()会返回true)
}
```

#### 4.3.4 导航栏状态显示

```vue
<!-- 发布状态标签 - 显示在"公开"旁边 -->
<el-tag
  :type="workflow.is_enable ? 'success' : 'warning'"
  size="small"
>
  {{ workflow.is_enable ? '已发布' : '未发布' }}
</el-tag>
```

**视觉规范**:
- 已发布: `success` 类型,绿色,文字"已发布"
- 未发布: `warning` 类型,橙色,文字"未发布"

---

## 五、Category字段 - SCM字典体系实现

### 5.1 字典表设计

#### 5.1.1 s_dict_type 字典类型

```sql
INSERT INTO s_dict_type (code, name, descr, c_id, c_time, u_id, u_time, is_del, dbversion)
VALUES (
    'ai_workflow_category',
    'AI工作流分类',
    '用于前端列表页筛选和UI展示的工作流分类,仅用于UI组织,不参与路由逻辑',
    1,
    NOW(),
    1,
    NOW(),
    0,
    0
);
```

#### 5.1.2 s_dict_data 字典数据

```sql
-- 获取dict_type的id
SET @dict_type_id = (SELECT id FROM s_dict_type WHERE code = 'ai_workflow_category');

-- 插入3个分类选项
INSERT INTO s_dict_data (code, dict_type_id, label, dict_value, sort, extra1, descr, c_id, c_time, u_id, u_time, is_del, dbversion)
VALUES
-- 0: 业务处理(默认)
('ai_workflow_category', @dict_type_id, '业务处理', '0', 1, '1', 'SCM订单、采购、库存等核心业务处理', 1, NOW(), 1, NOW(), 0, 0),

-- 1: 知识问答
('ai_workflow_category', @dict_type_id, '知识问答', '1', 2, '0', '基于知识库的文档检索和专业知识问答', 1, NOW(), 1, NOW(), 0, 0),

-- 2: 通用对话
('ai_workflow_category', @dict_type_id, '通用对话', '2', 3, '0', '一般性对话、闲聊、兜底分类', 1, NOW(), 1, NOW(), 0, 0);
```

**字段说明**:
- `dict_value`: `'0'`/`'1'`/`'2'` (实际存储在 `ai_workflow.category` 的值)
- `label`: 前端显示的中文标签
- `sort`: 排序(1最前)
- `extra1='1'`: 标记 `'0'`(业务处理) 为默认值

### 5.2 后端常量定义

**文件位置**: `scm-common/src/main/java/com/xinyirun/scm/common/constant/DictConstant.java`

```java
public class DictConstant {

    // ==================== AI工作流分类 ====================
    /**
     * 字典类型: AI工作流分类
     */
    public static final String DICT_AI_WORKFLOW_CATEGORY = "ai_workflow_category";

    /**
     * AI工作流分类-业务处理
     */
    public static final String DICT_AI_WORKFLOW_CATEGORY_BUSINESS = "0";

    /**
     * AI工作流分类-知识问答
     */
    public static final String DICT_AI_WORKFLOW_CATEGORY_KNOWLEDGE = "1";

    /**
     * AI工作流分类-通用对话
     */
    public static final String DICT_AI_WORKFLOW_CATEGORY_GENERAL = "2";

    // ... 其他字典常量
}
```

### 5.3 前端实现

#### 5.3.1 前端常量定义

**文件位置**: `src/common/constants/constants_dict.js`

```javascript
// AI工作流分类
const DICT_AI_WORKFLOW_CATEGORY = 'ai_workflow_category'
const DICT_AI_WORKFLOW_CATEGORY_BUSINESS = '0'
const DICT_AI_WORKFLOW_CATEGORY_KNOWLEDGE = '1'
const DICT_AI_WORKFLOW_CATEGORY_GENERAL = '2'

export default {
  // ... 其他字典常量

  // AI工作流分类
  DICT_AI_WORKFLOW_CATEGORY,
  DICT_AI_WORKFLOW_CATEGORY_BUSINESS,
  DICT_AI_WORKFLOW_CATEGORY_KNOWLEDGE,
  DICT_AI_WORKFLOW_CATEGORY_GENERAL
}
```

#### 5.3.2 工作流编辑器(使用SelectDict)

**文件位置**: `src/components/70_ai/components/workflow/WorkflowEditor.vue`

```vue
<template>
  <el-form :model="workflow" label-width="120px">

    <!-- 工作流分类 -->
    <el-form-item label="工作流分类" prop="category">
      <select-dict
        v-model="workflow.category"
        :para="CONSTANTS.DICT_AI_WORKFLOW_CATEGORY"
        init-placeholder="请选择工作流分类"
        :disabled="false"
        @change="handleCategoryChange"
      />
    </el-form-item>

    <!-- 工作流名称 -->
    <el-form-item label="工作流名称" prop="name" required>
      <el-input v-model="workflow.name" placeholder="请输入工作流名称" />
    </el-form-item>

    <!-- 详细描述 -->
    <el-form-item label="详细描述" prop="description">
      <el-input
        v-model="workflow.description"
        type="textarea"
        :rows="4"
        placeholder="请输入详细描述,供AI路由判断使用"
      />
    </el-form-item>

    <!-- 关键词 -->
    <el-form-item label="关键词" prop="keywords">
      <el-input
        v-model="workflow.keywords"
        placeholder="请输入关键词,逗号分隔,如: 订单,采购,库存"
      />
    </el-form-item>

  </el-form>
</template>

<script>
import SelectDict from '@/components/00_dict/select/SelectDict'
import CONSTANTS from '@/common/constants/constants_dict'

export default {
  components: { SelectDict },
  data() {
    return {
      CONSTANTS,
      workflow: {
        category: '',      // SelectDict会自动加载默认值(extra1='1'的'0')
        name: '',
        description: '',
        keywords: ''
      }
    }
  },
  methods: {
    handleCategoryChange(value, selectedData) {
      // value: '0'/'1'/'2'
      // selectedData: {value, name, label, extra1, extra2, extra3, extra4}
      console.log('选中分类:', selectedData.label) // "业务处理"
    }
  }
}
</script>
```

#### 5.3.3 工作流列表页(Tab筛选)

**文件位置**: `src/components/70_ai/components/workflow/WorkflowList.vue`

```vue
<template>
  <div class="workflow-list">

    <!-- Category Tab Filter -->
    <el-tabs v-model="activeCategory" @tab-click="loadWorkflows">
      <el-tab-pane label="全部" name="ALL"></el-tab-pane>
      <el-tab-pane
        v-for="cat in categoryOptions"
        :key="cat.value"
        :label="cat.label"
        :name="cat.value"
      ></el-tab-pane>
    </el-tabs>

    <!-- Workflow Cards -->
    <div class="workflow-cards">
      <workflow-card
        v-for="wf in workflows"
        :key="wf.id"
        :workflow="wf"
      />
    </div>

  </div>
</template>

<script>
import CONSTANTS from '@/common/constants/constants_dict'
import { getDictDataList } from '@/api/system/dict' // SCM通用字典API

export default {
  data() {
    return {
      CONSTANTS,
      activeCategory: 'ALL',
      categoryOptions: [], // 从字典表加载
      workflows: []
    }
  },
  mounted() {
    this.loadCategories()
    this.loadWorkflows()
  },
  methods: {
    // 加载分类字典
    async loadCategories() {
      const res = await getDictDataList(CONSTANTS.DICT_AI_WORKFLOW_CATEGORY)
      this.categoryOptions = res.data.map(item => ({
        value: item.dict_value,  // '0'/'1'/'2'
        label: item.label,        // '业务处理'/'知识问答'/'通用对话'
        sort: item.sort
      }))
    },

    // 加载工作流列表
    async loadWorkflows() {
      const category = this.activeCategory === 'ALL' ? null : this.activeCategory
      const res = await this.$api.getWorkflows({
        category: category,  // 传入字典值: '0'/'1'/'2'/null
        is_enable: true
      })
      this.workflows = res.data
    }
  }
}
</script>
```

#### 5.3.4 工作流卡片(显示分类Tag)

**文件位置**: `src/components/70_ai/components/workflow/WorkflowCard.vue`

```vue
<template>
  <el-card class="workflow-card" shadow="hover">
    <div class="card-header">
      <h3>{{ workflow.name }}</h3>

      <!-- Category Tag(从字典获取label) -->
      <el-tag
        :type="getCategoryType(workflow.category)"
        size="small"
      >
        {{ getCategoryLabel(workflow.category) }}
      </el-tag>
    </div>

    <div class="card-body">
      <p>{{ workflow.description }}</p>
    </div>
  </el-card>
</template>

<script>
import CONSTANTS from '@/common/constants/constants_dict'
import { getDictLabel } from '@/utils/dict' // SCM通用字典工具函数

export default {
  props: {
    workflow: {
      type: Object,
      required: true
    }
  },
  methods: {
    getCategoryLabel(value) {
      // 从字典缓存获取label
      // value='0' → '业务处理'
      // value='1' → '知识问答'
      // value='2' → '通用对话'
      return getDictLabel(CONSTANTS.DICT_AI_WORKFLOW_CATEGORY, value)
    },
    getCategoryType(value) {
      // 简单的颜色映射
      const typeMap = {
        '0': 'primary',   // 业务处理: 蓝色
        '1': 'success',   // 知识问答: 绿色
        '2': 'info'       // 通用对话: 灰色
      }
      return typeMap[value] || 'info'
    }
  }
}
</script>
```

### 5.4 Category字段颜色映射表

| dict_value | label | Element Type | 颜色 | 用途说明 |
|-----------|-------|-------------|------|---------|
| `'0'` | 业务处理 | primary | `#409EFF` 蓝色 | SCM核心业务,高频使用 |
| `'1'` | 知识问答 | success | `#67C23A` 绿色 | 知识检索,安全感 |
| `'2'` | 通用对话 | info | `#909399` 灰色 | 默认兜底,中性 |

### 5.5 Category字段的唯一用途

**✅ 唯一使用场景**: 前端UI分组筛选

- 工作流列表页的Tab筛选
- 工作流卡片的分类标签显示
- 工作流编辑器的分类选择

**❌ 不使用的场景**: 路由逻辑

- Layer 1(用户指定): 不使用category
- Layer 2(关键词匹配): 不使用category,只用keywords字段
- Layer 3(LLM路由): 不使用category,只分析description/name
- Layer 4(兜底策略): 不使用category

---

## 六、性能优化方案

### 6.1 性能目标

| 指标 | 目标值 | 实现方式 |
|------|--------|---------|
| P50延迟 | < 50ms | 70%请求命中关键词匹配 |
| P95延迟 | < 2s | LLM路由优化Prompt长度 |
| P99延迟 | < 3s | 设置LLM超时3秒,自动降级 |
| 路由准确率 | > 90% | 关键词+LLM双层保障 |

### 6.2 缓存策略

```java
@Service
public class WorkflowRoutingService {

    // 工作流缓存 (5分钟过期)
    @Cacheable(value = "workflow:available", key = "#tenantCode + ':' + #userId")
    public List<AiWorkflowEntity> getAvailableWorkflows(String tenantCode, Long userId) {
        return workflowService.getAvailableWorkflows(tenantCode, userId);
    }

    // 清除缓存 (发布/取消发布时)
    @CacheEvict(value = "workflow:available", allEntries = true)
    public void clearWorkflowCache() {
        // 自动清除
    }
}
```

### 6.3 LLM超时控制

```java
private String routeByLLM(String input, String tenantCode, Long userId) {
    try {
        return Mono.fromCallable(() -> {
            // LLM调用
            RoutingResponseVo response = chatClient.prompt(prompt)
                .call()
                .entity(RoutingResponseVo.class);
            return response.selection();
        })
        .timeout(Duration.ofSeconds(3)) // 3秒超时
        .onErrorReturn(null) // 超时返回null,进入Layer 4
        .block();

    } catch (Exception e) {
        log.error("LLM路由失败: {}", e.getMessage());
        return null;
    }
}
```

---

## 七、KISS原则验证

### 7.1 四个问题回答

**问题1: 这是个真问题还是臆想出来的?**
✅ **真问题**:
- 数据库已有3+个工作流,用户每次都要手动选择
- 高频操作,影响所有用户
- 产品定位是"智能助手",不是"工具选择器"

**问题2: 有更简单的方法吗?**
✅ **已是最简**:
- 去掉关键词层? → 性能差 (每次调LLM 1-2s)
- 去掉LLM层? → 准确率低 (关键词无法理解语义)
- 责任链模式是最简洁的多层路由实现

**问题3: 会破坏什么吗?**
✅ **零破坏**:
- 老接口 `chat(input, workflowId)` 完全兼容
- 数据库新增字段,不影响现有数据
- 前端 `workflowId` 参数变为可选,向后兼容

**问题4: 当前项目真的需要这个功能吗?**
✅ **强需求**:
- 产品定位: "SCM智能助手" 需要智能路由
- 用户期望: 一句话解决问题,不是先选工具
- 竞品对比: GPT/Claude都是直接对话

### 7.2 复杂度评估

**代码量**:
- Entity: ~100行 (包含辅助方法)
- Mapper: ~80行
- Service: ~150行
- RoutingService: ~200行
- Controller: ~50行
- VO: ~10行
- 前端: ~300行

**总计**: ~890行代码

**核心概念**: 4个 (路由器、工作流服务、执行器、流式响应)

**结论**: 复杂度适中,符合KISS原则

---

## 八、风险分析与缓解措施

| 风险项 | 严重程度 | 概率 | 缓解措施 |
|--------|---------|------|---------|
| LLM调用失败 | 中 | 20% | 3秒超时 + Layer 4兜底 |
| LLM路由错误 | 低 | 5% | 记录reasoning,用户可纠正 |
| 关键词配置质量差 | 中 | 30% | 提供配置指南,监控命中率 |
| 租户数据泄露 | 高 | <1% | SQL强制WHERE tenant_code,单元测试覆盖 |
| 性能问题 | 低 | 10% | 缓存 + 关键词优先 + LLM超时 |

---

## 九、测试计划

### 9.1 单元测试

```java
@Test
public void testKeywordMatching() {
    // 测试关键词匹配
    String input = "帮我查订单状态";
    String workflowId = routingService.matchByKeywords(input, "tenant_001", 1001L);
    assertEquals("14c91cd4...", workflowId); // SCM智能助手
}

@Test
public void testLLMRouting() {
    // 测试LLM路由
    String input = "我想了解一下采购流程";
    String workflowId = routingService.routeByLLM(input, "tenant_001", 1001L);
    assertNotNull(workflowId);
}

@Test
public void testFallback() {
    // 测试兜底策略
    String input = "随便聊聊";
    Flux<String> response = routingService.chat(input, "tenant_001", 1001L, null);
    assertNotNull(response);
}
```

### 9.2 集成测试

- 完整路由流程测试
- 权限控制测试
- 租户隔离测试
- 流式响应测试

### 9.3 性能测试

- 并发100用户,测试P50/P95/P99延迟
- 关键词匹配命中率统计
- LLM调用成功率统计

---

## 十、部署计划

### 10.1 数据库变更

```sql
-- 1. 执行DDL
SOURCE docs/design/2025-11-10-workflow-routing-ddl.sql

-- 2. 插入字典数据
SOURCE docs/design/2025-11-10-workflow-routing-dict.sql

-- 3. 更新示例数据
SOURCE docs/design/2025-11-10-workflow-routing-data.sql
```

### 10.2 后端部署

1. 打包: `mvn clean package -DskipTests`
2. 部署: 重启 scm-ai 服务
3. 验证: 检查 `/ai/chat/stream` 接口

### 10.3 前端部署

1. 构建: `npm run build:prod`
2. 部署: 更新前端静态资源
3. 验证: 测试工作流发布功能

---

## 十一、总结

### 11.1 核心设计亮点

1. ✅ **复用现有字段**: `is_enable` 作为发布状态,KISS原则
2. ✅ **责任链模式**: 4层路由,消除特殊情况
3. ✅ **零破坏性**: 向后兼容,老代码不改
4. ✅ **数据驱动**: 数据库驱动路由,配置灵活
5. ✅ **性能优化**: 关键词优先,LLM兜底
6. ✅ **简化设计**: 移除example_inputs,keywords改为VARCHAR,减少复杂度

### 11.2 实现复杂度

- **代码量**: ~890行
- **核心概念**: 4个
- **数据库变更**: 5个新字段 (已简化)
- **API接口**: 5个

### 11.3 预期效果

- **用户体验**: 从"选择工具"到"直接对话",体验提升80%
- **路由准确率**: 90%+
- **性能**: P50 < 50ms, P95 < 2s
- **稳定性**: 100% (永不失败,有兜底)

---

**方案设计完成,等待审批**
