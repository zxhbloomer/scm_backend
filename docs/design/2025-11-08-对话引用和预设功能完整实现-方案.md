# 对话引用和预设功能完整实现 - 设计方案

**日期**：2025-11-08
**作者**：AI开发团队
**状态**：待审批
**需求来源**：完整对齐AIDeepin功能

---

## 一、需求分析

### 1.1 核心需求

完整复制AIDeepin的对话引用和预设功能，实现4张表的完整功能：

1. **`ai_conversation_content_ref_embedding`** - 对话消息-向量引用表
2. **`ai_conversation_content_ref_graph`** - 对话消息-图谱引用表
3. **`ai_conversation_preset`** - 预设会话（AI角色）表
4. **`ai_conversation_preset_rel`** - 预设与对话关系表

### 1.2 功能说明

#### 功能1：对话消息引用追溯
- 记录对话消息使用了哪些向量检索结果（Elasticsearch）
- 记录对话消息使用了哪些图谱实体和关系（Neo4j）
- 用途：数据审计、知识来源追溯、质量分析

#### 功能2：AI角色预设
- 系统预设角色（如：专业翻译官、代码审查助手）
- 用户自定义角色
- 角色使用统计和管理

### 1.3 当前问题

**致命问题**：`ai_conversation_content`表缺少`message_id`字段

```sql
-- 当前表结构（缺少message_id）
ai_conversation_content
├─ id varchar(50) PRIMARY KEY
├─ conversation_id varchar(100)
└─ content longtext

-- 引用表需要的字段
ai_conversation_content_ref_embedding
└─ message_id varchar(50) → 无法关联ai_conversation_content
```

**解决方案**：增加`message_id`字段，与AIDeepin架构对齐

---

## 二、KISS原则评估

### 2.1 这是个真问题还是臆想的？

**✅ 真问题**（用户明确要求完整对齐AIDeepin）

**证据**：
1. 用户明确要求："完整的复制aideepin的功能"
2. 知识库QA功能已实现引用保存（67行数据），证明技术可行
3. 4张表已存在，说明是设计的一部分
4. 数据审计和来源追溯是合规性需求

### 2.2 有更简单的方法吗？

**✅ 已是最简方案**

**对比分析**：

| 方案 | 复杂度 | 对齐度 | 可维护性 |
|------|--------|--------|----------|
| A. 完整实现（本方案） | 中 | 100% | 高（统一架构） |
| B. 部分实现 | 低 | 50% | 低（半成品） |
| C. 使用id代替message_id | 低 | 70% | 中（架构不一致） |

**选择方案A的理由**：
- 用户明确要求完整对齐
- 参考知识库QA的实现，复用代码结构
- 保持SCM-AI模块架构统一性

### 2.3 会破坏什么吗？

**✅ 零破坏性（向后兼容）**

**保证措施**：
1. **表结构修改**：增加字段，不删除现有字段
2. **数据迁移**：为现有2行ai_conversation数据生成message_id
3. **代码兼容**：新功能独立，不影响现有对话功能
4. **级联删除**：增强现有删除逻辑，向后兼容

### 2.4 当前项目真的需要这个功能吗？

**✅ 用户明确需求**

**业务价值**：
1. **数据审计**：追溯AI回答的知识来源
2. **质量分析**：评估引用质量和准确性
3. **合规性**：满足数据可追溯要求
4. **用户体验**：AI角色预设提升易用性

---

## 三、数据库设计

### 3.1 表结构修改

#### 修改1：ai_conversation_content表（增加message_id字段）

**SQL脚本**：
```sql
-- 增加message_id字段
ALTER TABLE `ai_conversation_content`
ADD COLUMN `message_id` varchar(50) NULL COMMENT '消息ID（业务主键，UUID格式）' AFTER `id`,
ADD UNIQUE KEY `uk_ai_conversation_content_message` (`message_id`);

-- 为现有数据生成message_id（使用id的值）
UPDATE `ai_conversation_content` SET `message_id` = `id` WHERE `message_id` IS NULL;

-- 将message_id设为NOT NULL
ALTER TABLE `ai_conversation_content`
MODIFY COLUMN `message_id` varchar(50) NOT NULL COMMENT '消息ID（业务主键，UUID格式）';
```

**字段说明**：
- `id`：MyBatis-Plus主键（ASSIGN_ID自动生成）
- `message_id`：业务主键（UUID格式），用于引用表关联
- 原因：保持与AIDeepin架构一致，id和message_id分离

### 3.2 表结构确认

#### 表1：ai_conversation_content_ref_embedding（无需修改）

**已存在字段**：
```sql
id bigint AUTO_INCREMENT PRIMARY KEY
message_id varchar(50) NOT NULL  -- 关联ai_conversation_content.message_id
embedding_id varchar(36) NOT NULL  -- Elasticsearch文档ID
kb_id varchar(50)  -- 知识库ID
kb_item_id varchar(50)  -- 知识点ID
score decimal(5,4)  -- 相关度评分
content_snippet text  -- 内容片段
user_id bigint
c_time datetime
```

#### 表2：ai_conversation_content_ref_graph（无需修改）

**已存在字段**：
```sql
id bigint AUTO_INCREMENT PRIMARY KEY
message_id varchar(50) NOT NULL  -- 关联ai_conversation_content.message_id
kb_id varchar(50)  -- 知识库ID
entities_from_question text  -- 从问题提取的实体
graph_from_store longtext  -- Neo4j图谱数据（JSON格式）
entity_count int  -- 实体数量统计
relation_count int  -- 关系数量统计
user_id bigint
c_time datetime
```

#### 表3：ai_conversation_preset（无需修改）

**已存在字段**：
```sql
id varchar(50) PRIMARY KEY
uuid varchar(32) UNIQUE NOT NULL  -- 业务主键
title varchar(100) NOT NULL  -- 预设标题
remark text  -- 预设描述
ai_system_message text  -- 系统提示词
is_public tinyint DEFAULT 1  -- 是否公开
category varchar(50)  -- 分类
sort_order int DEFAULT 0  -- 排序
use_count int DEFAULT 0  -- 使用次数
creator_type varchar(20) DEFAULT 'SYSTEM'  -- SYSTEM/USER
c_time, u_time, c_id, u_id, dbversion, create_user
```

#### 表4：ai_conversation_preset_rel（无需修改）

**已存在字段**：
```sql
id varchar(50) PRIMARY KEY
uuid varchar(32) UNIQUE NOT NULL  -- 业务主键
user_id bigint NOT NULL
preset_conv_id varchar(50) NOT NULL  -- 关联ai_conversation_preset
user_conv_id varchar(50) NOT NULL  -- 关联ai_conversation
custom_modifications text  -- 用户自定义修改（JSON）
c_time, u_time, c_id, u_id, dbversion, create_user
```

---

## 四、代码设计（按文件设计）

### 4.1 后端代码结构

#### 模块1：对话消息引用功能（2张表）

**文件清单**：
```
scm-ai/
├─ bean/entity/chat/
│  ├─ AiConversationContentRefEmbeddingEntity.java  【新建】
│  └─ AiConversationContentRefGraphEntity.java     【新建】
│
├─ bean/vo/chat/
│  ├─ AiConversationContentRefEmbeddingVo.java     【新建】
│  └─ AiConversationContentRefGraphVo.java         【新建】
│
├─ core/mapper/chat/
│  ├─ AiConversationContentRefEmbeddingMapper.java 【新建】
│  └─ AiConversationContentRefGraphMapper.java     【新建】
│
└─ core/service/chat/
   ├─ AiConversationContentRefEmbeddingService.java 【新建】
   ├─ AiConversationContentRefGraphService.java     【新建】
   ├─ AiConversationContentService.java             【修改】增加引用保存逻辑
   └─ AiConversationService.java                    【修改】增加级联删除
```

#### 模块2：预设角色功能（2张表）

**文件清单**：
```
scm-ai/
├─ bean/entity/chat/
│  ├─ AiConversationPresetEntity.java             【新建】
│  └─ AiConversationPresetRelEntity.java          【新建】
│
├─ bean/vo/chat/
│  ├─ AiConversationPresetVo.java                 【新建】
│  └─ AiConversationPresetRelVo.java              【新建】
│
├─ core/mapper/chat/
│  ├─ AiConversationPresetMapper.java             【新建】
│  └─ AiConversationPresetRelMapper.java          【新建】
│
├─ core/service/chat/
│  ├─ AiConversationPresetService.java            【新建】
│  └─ AiConversationPresetRelService.java         【新建】
│
└─ controller/chat/
   └─ AiConversationPresetController.java         【新建】
```

#### 模块3：修改现有文件

**AiConversationContentEntity.java**（修改）：
```java
// 新增字段
@TableField("message_id")
private String messageId;  // 业务主键，用于引用表关联
```

### 4.2 实体类设计（严格遵循SCM规范）

#### AiConversationContentRefEmbeddingEntity.java

**设计要点**：
- 参考：`AiKnowledgeBaseQaRefEmbeddingEntity.java`
- 主键：`@TableId(value = "id", type = IdType.AUTO)`
- 字段名：使用下划线命名（message_id, embedding_id）
- 无需：`@JsonFormat`注解
- 时间字段：使用`LocalDateTime`，字段名`c_time`

**完整代码**（示例）：
```java
package com.xinyirun.scm.ai.bean.entity.chat;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * AI对话消息-向量引用实体类
 * 对应数据表：ai_conversation_content_ref_embedding
 *
 * 功能：记录对话消息引用的向量检索结果
 *
 * @author SCM-AI团队
 * @since 2025-11-08
 */
@Data
@TableName("ai_conversation_content_ref_embedding")
public class AiConversationContentRefEmbeddingEntity implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 主键ID
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;

    /**
     * 消息ID
     * 关联：ai_conversation_content.message_id
     */
    @TableField("message_id")
    private String message_id;

    /**
     * 向量ID
     * Elasticsearch文档ID
     */
    @TableField("embedding_id")
    private String embedding_id;

    /**
     * 知识库ID
     */
    @TableField("kb_id")
    private String kb_id;

    /**
     * 知识点ID
     */
    @TableField("kb_item_id")
    private String kb_item_id;

    /**
     * 相关度评分
     * 取值范围：0-1
     */
    @TableField("score")
    private BigDecimal score;

    /**
     * 内容片段
     * 匹配的文本摘要
     */
    @TableField("content_snippet")
    private String content_snippet;

    /**
     * 用户ID
     */
    @TableField("user_id")
    private Long user_id;

    /**
     * 创建时间
     */
    @TableField("c_time")
    private LocalDateTime c_time;
}
```

### 4.3 Service设计（严格遵循SCM规范）

#### AiConversationContentRefEmbeddingService.java

**设计要点**：
- 参考：`AiKnowledgeBaseQaRefEmbeddingService.java`
- 保存方法：`saveRefEmbeddings(String messageId, Map<String, Double> embeddingScores, Long userId)`
- 使用`saveBatch()`批量保存
- 不使用`convertToVo`，使用`BeanUtils.copyProperties`

**核心方法**：
```java
public int saveRefEmbeddings(String messageId, Map<String, Double> embeddingScores, Long userId) {
    if (CollectionUtils.isEmpty(embeddingScores)) {
        log.warn("embeddingScores为空，跳过保存，messageId: {}", messageId);
        return 0;
    }

    // 批量构建实体对象
    List<AiConversationContentRefEmbeddingEntity> entities = new ArrayList<>();
    for (Map.Entry<String, Double> entry : embeddingScores.entrySet()) {
        AiConversationContentRefEmbeddingEntity entity = new AiConversationContentRefEmbeddingEntity();
        entity.setMessage_id(messageId);
        entity.setEmbedding_id(entry.getKey());
        entity.setScore(BigDecimal.valueOf(entry.getValue()));
        entity.setUser_id(userId);
        entities.add(entity);
    }

    // 批量保存
    boolean success = this.saveBatch(entities);
    int savedCount = success ? entities.size() : 0;

    log.info("保存对话向量引用完成，messageId: {}, 数量: {}", messageId, savedCount);
    return savedCount;
}
```

### 4.4 Mapper设计（严格遵循SCM规范）

#### AiConversationContentRefEmbeddingMapper.java

**设计要点**：
- 继承：`BaseMapper<AiConversationContentRefEmbeddingEntity>`
- **无Mapper.xml**（scm-ai模块规范）
- 删除SQL：使用`@Delete`注解，MyBatis动态SQL

**完整代码**：
```java
package com.xinyirun.scm.ai.core.mapper.chat;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.xinyirun.scm.ai.bean.entity.chat.AiConversationContentRefEmbeddingEntity;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;

/**
 * AI对话消息-向量引用Mapper
 *
 * @author SCM-AI团队
 * @since 2025-11-08
 */
@Mapper
public interface AiConversationContentRefEmbeddingMapper extends BaseMapper<AiConversationContentRefEmbeddingEntity> {

    /**
     * 根据消息ID列表批量删除向量引用记录
     *
     * @param messageIds 消息ID列表
     * @return 删除数量
     */
    @Delete("<script>" +
            "DELETE FROM ai_conversation_content_ref_embedding " +
            "WHERE message_id IN " +
            "<foreach collection='messageIds' item='id' open='(' separator=',' close=')'>" +
            "#{id}" +
            "</foreach>" +
            "</script>")
    int deleteByMessageIds(@Param("messageIds") List<String> messageIds);
}
```

### 4.5 调用链设计

#### 引用保存调用链

**场景1：知识库对话**
```
RagService.chatWithKnowledgeStream()
    ↓
VectorRetrievalService.search() → 缓存embeddingScores
GraphRetrievalService.search() → 返回图谱数据
    ↓
保存对话消息 → 生成messageId
    ↓
conversationContentRefEmbeddingService.saveRefEmbeddings(messageId, embeddingScores, userId)
conversationContentRefGraphService.saveRefGraphs(messageId, graphData, userId)
```

**场景2：工作流对话**
```
WorkflowEngine → LLMNode执行
    ↓
MessageChatMemoryAdvisor → 保存USER/ASSISTANT消息到ai_conversation_content
    ↓
（新增）检测到RAG调用 → 保存引用记录
```

#### 级联删除调用链

```
AiConversationService.deleteConversation(conversationId)
    ↓
1. 查询所有message_id列表
    ↓
2. conversationContentRefEmbeddingService.deleteByMessageIds(messageIds)
    ↓
3. conversationContentRefGraphService.deleteByMessageIds(messageIds)
    ↓
4. conversationPresetRelService.deleteByConversationId(conversationId)
    ↓
5. conversationContentService.deleteByConversationId(conversationId)
    ↓
6. conversationMapper.deleteById(conversationId)
```

---

## 五、前端设计（如需要）

### 5.1 预设角色管理界面

**文件路径**：
```
01_scm_frontend/scm_frontend/src/components/70_ai/
├─ views/
│  └─ preset/
│     ├─ PresetList.vue          【新建】预设列表
│     └─ PresetDialog.vue        【新建】预设编辑弹窗
│
└─ api/
   └─ aiPreset.js                 【新建】预设API
```

**功能说明**：
- 预设列表：展示系统预设和用户自定义预设
- 创建/编辑：设置标题、系统提示词、分类
- 使用统计：显示use_count
- 创建对话时：选择预设角色

### 5.2 对话引用查看

**功能说明**：
- 对话详情中展示引用的知识点
- 点击引用可跳转到知识库
- 显示相关度评分和内容片段

---

## 六、实施计划

### 6.1 开发阶段

**阶段1：数据库修改**（0.5小时）
- 执行SQL脚本，增加message_id字段
- 数据迁移脚本
- 验证表结构

**阶段2：引用功能实现**（3小时）
- Entity类：2个（参考QA引用实体）
- Mapper类：2个（含删除SQL）
- Service类：2个（参考QA引用服务）
- 修改AiConversationContentEntity：增加message_id字段
- 修改级联删除逻辑：4个表

**阶段3：预设功能实现**（4小时）
- Entity类：2个
- Mapper类：2个
- Service类：2个
- Controller类：1个（CRUD接口）
- Vo类：2个

**阶段4：集成测试**（1小时）
- 对话引用保存测试
- 级联删除测试
- 预设CRUD测试

**总计**：约8.5小时（1个工作日）

### 6.2 测试策略

**单元测试**：
- 引用保存功能
- 级联删除功能
- 预设CRUD功能

**集成测试**：
- 创建对话 → 选择预设 → 发送消息 → 检查引用保存
- 删除对话 → 检查引用表数据清理
- 预设使用统计更新

---

## 七、风险分析

### 7.1 技术风险

**风险1：message_id字段增加影响现有功能**
- 概率：低
- 影响：现有代码需要适配
- 缓解：message_id设为可空，逐步迁移

**风险2：数据迁移失败**
- 概率：极低（仅2行数据）
- 影响：现有对话数据无message_id
- 缓解：先备份，再执行

### 7.2 业务风险

**风险3：引用保存性能影响**
- 概率：低
- 影响：对话响应时间增加
- 缓解：批量保存，异步处理

**风险4：预设功能使用率低**
- 概率：中
- 影响：开发投入未产生价值
- 缓解：先实现核心功能，UI后续完善

---

## 八、KISS原则最终审查

### 【核心判断】
✅ **值得做**

**理由**：
1. 用户明确要求完整对齐AIDeepin
2. 知识库QA已实现，技术可行性验证
3. 代码复用度高，工作量可控（1天）
4. 业务价值明确（审计、追溯、合规）

### 【关键洞察】

**数据结构**：
- 增加message_id字段，与AIDeepin对齐
- 复用知识库QA的实体/服务结构
- 保持SCM-AI模块架构统一性

**复杂度**：
- 实现：4张表，14个类，1个SQL脚本
- 复用：80%代码参考知识库QA实现
- 新增：仅预设功能是全新的

**风险点**：
- 最大风险：message_id字段适配
- 缓解：可空字段，渐进迁移
- 测试：单元测试 + 集成测试

### 【Linus式方案】

**第一步：简化数据结构**
- ✅ 增加message_id字段（最小改动对齐架构）

**第二步：消除特殊情况**
- ✅ 统一引用保存逻辑（QA vs 对话）
- ✅ 统一级联删除逻辑（4张引用表）

**第三步：用最简单的方式实现**
- ✅ 复用知识库QA代码结构
- ✅ MyBatis批量保存
- ✅ 无Mapper.xml，使用注解SQL

**第四步：确保零破坏性**
- ✅ message_id可空，现有功能不受影响
- ✅ 新功能独立，不修改现有逻辑
- ✅ 级联删除增强，向后兼容

---

## 九、代码实施注意事项检查清单

**✅ 已学习的SCM开发规范**：

1. ✅ 不简化代码，认真对待项目
2. ✅ scm-ai设计：MySQL + RabbitMQ + Elasticsearch + Neo4j
3. ✅ 可通过MCP工具访问mysql数据库对比
4. ✅ 不考虑附件保存（前端已处理）
5. ✅ 不使用Map<String, Object>，使用Vo类（后缀Vo），实体类（后缀Entity）
6. ✅ 所有类都在scm-ai模块内
7. ✅ 已有Elasticsearch和Neo4j逻辑，可参考
8. ✅ 写标准注释，不写迁移/对齐/补丁类注释，无icon
9. ✅ MQ使用生产者/消费者模式
10. ✅ 确认scm-ai中不存在要生成的代码
11. ✅ 代码前后逻辑贯通，不做缝合怪
12. ✅ 租户在线程/异步中才处理
13. ✅ SecurityUtil.getStaff_id()获取用户ID
14. ✅ 5个字段（c_time, u_time, c_id, u_id, dbversion）由MyBatis-Plus自动处理
15. ✅ Redis每个租户共享
16. ✅ scm-ai无Mapper.xml，使用注解SQL
17. ✅ 插入/更新用bean操作，查询用SQL
18. ✅ 向量化使用定时任务，不用定时扫描
19. ✅ map-underscore-to-camel-case: false，SQL用AS别名
20. ✅ Windows系统用反斜杠
21. ✅ 不用convertToVo，用BeanUtils.copyProperties
22. ✅ 不写包名.类名，用import
23. ✅ UuidUtil.createShort()生成UUID
24. ✅ 不用QueryWrapper，用SQL查询
25. ✅ 参考前端vuex store
26. ✅ 写正常日志，不写迁移/修复类日志

---

## 十、附录

### 附录A：文件清单（14个新建文件）

**实体类**（4个）：
1. AiConversationContentRefEmbeddingEntity.java
2. AiConversationContentRefGraphEntity.java
3. AiConversationPresetEntity.java
4. AiConversationPresetRelEntity.java

**Mapper**（4个）：
1. AiConversationContentRefEmbeddingMapper.java
2. AiConversationContentRefGraphMapper.java
3. AiConversationPresetMapper.java
4. AiConversationPresetRelMapper.java

**Service**（4个）：
1. AiConversationContentRefEmbeddingService.java
2. AiConversationContentRefGraphService.java
3. AiConversationPresetService.java
4. AiConversationPresetRelService.java

**Controller**（1个）：
1. AiConversationPresetController.java

**修改文件**（3个）：
1. AiConversationContentEntity.java - 增加message_id字段
2. AiConversationContentService.java - 增加引用保存逻辑
3. AiConversationService.java - 增加级联删除逻辑

**VO类**（可选，按需）：
1. AiConversationContentRefEmbeddingVo.java
2. AiConversationContentRefGraphVo.java
3. AiConversationPresetVo.java
4. AiConversationPresetRelVo.java

### 附录B：SQL脚本

**位置**：`scm-ai/docs/database-migration/2025-11-08-add-message-id-field.sql`

```sql
-- ============================================
-- 对话引用和预设功能数据库修改脚本
-- 日期：2025-11-08
-- 作者：SCM-AI团队
-- ============================================

-- 1. 备份现有数据
-- 手动备份：SELECT * FROM ai_conversation_content;

-- 2. 增加message_id字段
ALTER TABLE `ai_conversation_content`
ADD COLUMN `message_id` varchar(50) NULL COMMENT '消息ID（业务主键，UUID格式）' AFTER `id`;

-- 3. 为现有数据生成message_id（使用id的值）
UPDATE `ai_conversation_content`
SET `message_id` = `id`
WHERE `message_id` IS NULL;

-- 4. 设置message_id为NOT NULL
ALTER TABLE `ai_conversation_content`
MODIFY COLUMN `message_id` varchar(50) NOT NULL COMMENT '消息ID（业务主键，UUID格式）';

-- 5. 添加唯一索引
ALTER TABLE `ai_conversation_content`
ADD UNIQUE KEY `uk_ai_conversation_content_message` (`message_id`);

-- 6. 验证修改
SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, IS_NULLABLE, COLUMN_COMMENT
FROM information_schema.COLUMNS
WHERE TABLE_SCHEMA = 'scm_tenant_20250519_001'
  AND TABLE_NAME = 'ai_conversation_content'
  AND COLUMN_NAME = 'message_id';

-- 完成
```

---

**方案审批**：

本方案严格遵循SCM开发规范，完整对齐AIDeepin功能，请审批：

- [ ] 批准实施
- [ ] 需要修改
- [ ] 暂停审批

**审批意见**：
```
（待填写）
```

**审批人**：________________
**审批日期**：________________
