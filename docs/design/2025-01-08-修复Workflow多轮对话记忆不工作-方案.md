# 修复 Workflow 多轮对话记忆不工作问题 - 技术方案（官方规范版）

**创建日期**: 2025-01-08
**版本**: v2.0（基于 Spring AI 官方文档）
**问题状态**: 🔴 严重 - 核心功能完全失效
**影响范围**: Workflow 域和 Chat 域的多轮对话记忆功能

---

## 问题描述

### 现象
用户在 Workflow 执行中进行多轮对话时，AI 无法记住之前的对话内容：
- 第1轮对话：用户说 "我叫小王"，AI 正常回复
- 第2轮对话：用户问 "我是谁"，AI 回答 "不确定您的具体意图"（应该回答 "你是小王"）

### 影响
- Workflow 域：✅ **已确认失效** - 多轮对话记忆完全不工作
- Chat 域：❓ **待验证** - 可能存在同样问题（代码结构相同）

---

## 根因分析

### 调用链路追踪

**完整调用流程**：
```
WorkflowUtil.streamingInvokeLLM()
  └─> AiChatBaseService.chatWithWorkflowMemoryStream()
      └─> getClient().prompt()
          └─> .advisors(workflowMessageChatMemoryAdvisor)  // ⚠️ 第1次调用
          └─> .advisors(a -> a.param(...))                // ⚠️ 第2次调用
          └─> .stream()
```

### 日志证据

**查询历史消息成功（Line 2049）**：
```
2025-11-08 17:23:41.113 DEBUG - 查询工作流对话历史成功,
conversation_id: scm_tenant_20250519_001::1746fd485e6c47c59f8b8e14e7bd7728::164,
limit: 10, 查询结果数: 2
```

**发送给 LLM 的请求中没有历史消息（Line 2143）**：
```
Encoding [ChatCompletionRequest[messages=[ChatCompletionMessage[rawContent=【用户问题】：我是谁...
```
→ **只包含当前问题，不包含历史对话 "我叫小王"**

### 代码问题定位

**当前代码（AiChatBaseService.java:178-180）**：
```java
.advisors(workflowMessageChatMemoryAdvisor)  // 方法1：advisors(Advisor... advisors)
.advisors(a -> a.param(ChatMemory.CONVERSATION_ID, aiChatOption.getConversationId()))  // 方法2：advisors(Consumer<AdvisorSpec>)
```

**问题分析**：
1. 第1次调用：使用 `advisors(Advisor... advisors)` 重载，直接添加 advisor 实例
2. 第2次调用：使用 `advisors(Consumer<AdvisorSpec>)` 重载，创建新的 AdvisorSpec 配置
3. **推测**：第2次调用可能重新初始化了 advisor 配置，导致第1次添加的 advisor 丢失

### Spring AI 官方推荐用法（来自 Context7 文档）

**官方推荐方式：在 ChatClient.builder() 时配置 defaultAdvisors**：
```java
var chatClient = ChatClient.builder(chatModel)
    .defaultAdvisors(
        MessageChatMemoryAdvisor.builder(chatMemory).build()  // 在构建时配置
    )
    .build();

String response = this.chatClient.prompt()
    .advisors(advisor -> advisor.param(ChatMemory.CONVERSATION_ID, conversationId))  // 只设置参数
    .user(userText)
    .call()
    .content();
```

**来源**：`https://github.com/spring-projects/spring-ai/blob/main/spring-ai-docs/src/main/antora/modules/ROOT/pages/api/advisors.adoc`

---

## KISS 原则验证

### 1. "这是个真问题还是臆想出来的？"
✅ **真问题** - 有日志证据：
- `ChatMemory.get()` 返回 2 条历史消息
- LLM 请求中只有当前消息
- 用户实际测试失败

### 2. "有更简单的方法吗？"
✅ **遵循官方规范是最简单的** - 按官方文档实现：
- 为每个域创建独立的 ChatClient Bean（配置 defaultAdvisors）
- 使用时只需设置 conversationId 参数
- 符合 Spring 依赖注入和领域解耦设计

### 3. "会破坏什么吗？"
✅ **零破坏** - 向后兼容：
- 只增加 Bean 定义，不修改现有逻辑
- Chat 域和 Workflow 域保持解耦
- 不影响无记忆模式的调用

### 4. "当前项目真的需要这个功能吗？"
✅ **核心功能** - 必须修复：
- 多轮对话是 AI 对话的基础能力
- Workflow 节点需要上下文记忆
- 用户已经开始使用并发现问题

---

## 设计方案（遵循 Spring AI 官方规范）

### 方案概述

**核心思路**：
- 为 Chat 域和 Workflow 域各创建一个独立的 ChatClient Bean
- 在 ChatClient.builder() 时配置对应的 MessageChatMemoryAdvisor（官方推荐方式）
- 使用时只需设置 conversationId 参数，不再需要动态添加 advisor
- 保持领域解耦，符合 Spring 依赖注入设计模式

### 修改文件清单

| 文件 | 修改类型 | 说明 |
|------|----------|------|
| `AiChatMemoryConfig.java` | 新增 | 添加 2 个 ChatClient Bean 定义 |
| `AiChatBaseService.java` | 修改 | 注入并使用领域专用 ChatClient (4处) |

### 详细修改方案

#### 文件1: AiChatMemoryConfig.java（新增 Bean 定义）

**文件路径**: `scm-ai/src/main/java/com/xinyirun/scm/ai/config/memory/AiChatMemoryConfig.java`

**修改内容**：

```java
package com.xinyirun.scm.ai.config.memory;

import com.xinyirun.scm.ai.config.AiModelProvider;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.client.advisor.MessageChatMemoryAdvisor;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * AI聊天记忆配置类
 *
 * 提供Chat和Workflow两个领域的MessageChatMemoryAdvisor Bean配置
 * 以及对应的ChatClient Bean配置（遵循Spring AI官方推荐方式）
 *
 * @Author: jianxing (原作者)
 * @CreateTime: 2025-05-27  18:36 (原创建时间)
 * @Migration: 2025-09-21 (迁移到scm-ai)
 * @Update: 2025-01-08 (领域拆分重构 + 官方规范改造)
 */
@Configuration
public class AiChatMemoryConfig {

    /**
     * Chat领域消息聊天记忆顾问
     *
     * 用于管理Chat领域的AI对话上下文记忆，支持多轮对话的连续性
     * 查询 ai_conversation_content 表
     *
     * @param chatMessageChatMemory Chat领域聊天记忆实现
     * @return MessageChatMemoryAdvisor实例
     */
    @Bean("chatMessageChatMemoryAdvisor")
    public MessageChatMemoryAdvisor chatMessageChatMemoryAdvisor(ScmChatMessageChatMemory chatMessageChatMemory) {
        return MessageChatMemoryAdvisor.builder(chatMessageChatMemory).build();
    }

    /**
     * Workflow领域消息聊天记忆顾问
     *
     * 用于管理Workflow领域的AI对话上下文记忆，支持多轮对话的连续性
     * 查询 ai_workflow_conversation_content 表
     *
     * @param workflowMessageChatMemory Workflow领域聊天记忆实现
     * @return MessageChatMemoryAdvisor实例
     */
    @Bean("workflowMessageChatMemoryAdvisor")
    public MessageChatMemoryAdvisor workflowMessageChatMemoryAdvisor(ScmWorkflowMessageChatMemory workflowMessageChatMemory) {
        return MessageChatMemoryAdvisor.builder(workflowMessageChatMemory).build();
    }

    /**
     * Chat领域专用ChatClient（配置了Chat域的记忆顾问）
     *
     * 遵循Spring AI官方推荐方式：在builder时配置defaultAdvisors
     * 官方文档：https://docs.spring.io/spring-ai/reference/api/advisors.html
     *
     * @param aiModelProvider AI模型提供者（用于获取ChatModel）
     * @param chatMessageChatMemoryAdvisor Chat领域记忆顾问
     * @return Chat领域专用ChatClient实例
     */
    @Bean("chatDomainChatClient")
    public ChatClient chatDomainChatClient(AiModelProvider aiModelProvider,
                                           MessageChatMemoryAdvisor chatMessageChatMemoryAdvisor) {
        ChatModel chatModel = aiModelProvider.getChatModel();
        return ChatClient.builder(chatModel)
                .defaultAdvisors(chatMessageChatMemoryAdvisor)  // Chat域记忆顾问
                .build();
    }

    /**
     * Workflow领域专用ChatClient（配置了Workflow域的记忆顾问）
     *
     * 遵循Spring AI官方推荐方式：在builder时配置defaultAdvisors
     * 官方文档：https://docs.spring.io/spring-ai/reference/api/advisors.html
     *
     * @param aiModelProvider AI模型提供者（用于获取ChatModel）
     * @param workflowMessageChatMemoryAdvisor Workflow领域记忆顾问
     * @return Workflow领域专用ChatClient实例
     */
    @Bean("workflowDomainChatClient")
    public ChatClient workflowDomainChatClient(AiModelProvider aiModelProvider,
                                               MessageChatMemoryAdvisor workflowMessageChatMemoryAdvisor) {
        ChatModel chatModel = aiModelProvider.getChatModel();
        return ChatClient.builder(chatModel)
                .defaultAdvisors(workflowMessageChatMemoryAdvisor)  // Workflow域记忆顾问
                .build();
    }
}
```

**关键变更**：
1. 新增 `chatDomainChatClient` Bean：Chat 域专用，配置了 chatMessageChatMemoryAdvisor
2. 新增 `workflowDomainChatClient` Bean：Workflow 域专用，配置了 workflowMessageChatMemoryAdvisor
3. 使用 `AiModelProvider.getChatModel()` 获取 ChatModel（保持租户级缓存）
4. 遵循 Spring AI 官方推荐：在 builder 时配置 defaultAdvisors

---

#### 文件2: AiChatBaseService.java（使用领域专用 ChatClient）

**文件路径**: `scm-ai/src/main/java/com/xinyirun/scm/ai/core/service/chat/AiChatBaseService.java`

**修改位置 1**: 注入领域专用 ChatClient（新增字段）

**修改前**：
```java
@Service
@Slf4j
@Transactional(rollbackFor = Exception.class)
public class AiChatBaseService {

    @Resource
    MessageChatMemoryAdvisor chatMessageChatMemoryAdvisor;
    @Resource
    MessageChatMemoryAdvisor workflowMessageChatMemoryAdvisor;
    // ... 其他字段
```

**修改后**：
```java
@Service
@Slf4j
@Transactional(rollbackFor = Exception.class)
public class AiChatBaseService {

    @Resource
    MessageChatMemoryAdvisor chatMessageChatMemoryAdvisor;
    @Resource
    MessageChatMemoryAdvisor workflowMessageChatMemoryAdvisor;

    // 新增：注入领域专用 ChatClient
    @Resource
    @Qualifier("chatDomainChatClient")
    private ChatClient chatDomainChatClient;

    @Resource
    @Qualifier("workflowDomainChatClient")
    private ChatClient workflowDomainChatClient;

    // ... 其他字段
```

**修改位置 2**: Line 144-161 - chatWithMemoryStream() 方法

**修改前**：
```java
public ChatClient.StreamResponseSpec chatWithMemoryStream(AIChatOptionVo aiChatOption) {
    // Chat领域专用，conversationId已包含租户信息，直接使用即可
    if (StringUtils.isNotBlank(aiChatOption.getSystem())) {
        return getClient(aiChatOption.getModule())
                .prompt()
                .system(aiChatOption.getSystem())
                .user(aiChatOption.getPrompt())
                .advisors(chatMessageChatMemoryAdvisor)
                .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, aiChatOption.getConversationId()))
                .stream();
    }
    return getClient(aiChatOption.getModule())
            .prompt()
            .user(aiChatOption.getPrompt())
            .advisors(chatMessageChatMemoryAdvisor)
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, aiChatOption.getConversationId()))
            .stream();
}
```

**修改后**：
```java
public ChatClient.StreamResponseSpec chatWithMemoryStream(AIChatOptionVo aiChatOption) {
    // Chat领域专用，使用 chatDomainChatClient（已配置 chatMessageChatMemoryAdvisor）
    // conversationId已包含租户信息，直接使用即可
    if (StringUtils.isNotBlank(aiChatOption.getSystem())) {
        return chatDomainChatClient
                .prompt()
                .system(aiChatOption.getSystem())
                .user(aiChatOption.getPrompt())
                .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, aiChatOption.getConversationId()))
                .stream();
    }
    return chatDomainChatClient
            .prompt()
            .user(aiChatOption.getPrompt())
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, aiChatOption.getConversationId()))
            .stream();
}
```

**修改位置 3**: Line 171-188 - chatWithWorkflowMemoryStream() 方法

**修改前**：
```java
public ChatClient.StreamResponseSpec chatWithWorkflowMemoryStream(AIChatOptionVo aiChatOption) {
    // Workflow领域专用，conversationId已包含租户信息，直接使用即可
    if (StringUtils.isNotBlank(aiChatOption.getSystem())) {
        return getClient(aiChatOption.getModule())
                .prompt()
                .system(aiChatOption.getSystem())
                .user(aiChatOption.getPrompt())
                .advisors(workflowMessageChatMemoryAdvisor)
                .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, aiChatOption.getConversationId()))
                .stream();
    }
    return getClient(aiChatOption.getModule())
            .prompt()
            .user(aiChatOption.getPrompt())
            .advisors(workflowMessageChatMemoryAdvisor)
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, aiChatOption.getConversationId()))
            .stream();
}
```

**修改后**：
```java
public ChatClient.StreamResponseSpec chatWithWorkflowMemoryStream(AIChatOptionVo aiChatOption) {
    // Workflow领域专用，使用 workflowDomainChatClient（已配置 workflowMessageChatMemoryAdvisor）
    // conversationId已包含租户信息，直接使用即可
    if (StringUtils.isNotBlank(aiChatOption.getSystem())) {
        return workflowDomainChatClient
                .prompt()
                .system(aiChatOption.getSystem())
                .user(aiChatOption.getPrompt())
                .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, aiChatOption.getConversationId()))
                .stream();
    }
    return workflowDomainChatClient
            .prompt()
            .user(aiChatOption.getPrompt())
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, aiChatOption.getConversationId()))
            .stream();
}
```

**关键变更**：
1. 使用 `chatDomainChatClient` 替代 `getClient()`（Chat 域）
2. 使用 `workflowDomainChatClient` 替代 `getClient()`（Workflow 域）
3. **移除** `.advisors(advisor)` 调用（advisor 已在 ChatClient 构建时配置）
4. **保留** `.advisors(a -> a.param(...))` 调用（只设置 conversationId 参数）
5. 完全符合 Spring AI 官方推荐用法

---

## 数据支撑

### 官方文档引用

**来源**：Spring AI 官方文档 - Chat Memory Advisor
**URL**: `https://github.com/spring-projects/spring-ai/blob/main/spring-ai-docs/src/main/antora/modules/ROOT/pages/api/advisors.adoc`

**官方代码示例**：
```java
ChatMemory chatMemory = ... // Initialize your chat memory store
VectorStore vectorStore = ... // Initialize your vector store

var chatClient = ChatClient.builder(chatModel)
    .defaultAdvisors(
        MessageChatMemoryAdvisor.builder(chatMemory).build(), // chat-memory advisor
        QuestionAnswerAdvisor.builder(vectorStore).build()    // RAG advisor
    )
    .build();

var conversationId = "678";

String response = this.chatClient.prompt()
    // Set advisor parameters at runtime
    .advisors(advisor -> advisor.param(ChatMemory.CONVERSATION_ID, conversationId))
    .user(userText)
    .call()
	.content();
```

### 日志分析

**第二次对话的完整执行流程**：

1. **保存用户消息**（Line 1994）：
   ```
   INSERT INTO ai_workflow_conversation_content (type='user', content='我是谁...')
   ```

2. **查询历史消息**（Line 2049）：
   ```
   SELECT ... FROM ai_workflow_conversation_content
   WHERE conversation_id = '...'
   ORDER BY c_time DESC
   LIMIT 1, 10
   ```
   → **结果**：返回 2 条（user: "我叫小王", assistant: "回复"）

3. **发送 LLM 请求**（Line 2143）：
   ```
   ChatCompletionRequest[messages=[ChatCompletionMessage[rawContent=【用户问题】：我是谁...
   ```
   → **问题**：只有当前消息，缺少历史的 2 条消息

---

## 架构设计优势

### 1. 符合 Spring AI 官方规范
- 严格遵循官方文档推荐的 defaultAdvisors 配置方式
- 避免在 prompt() 时动态添加 advisor（可能导致配置覆盖）
- 充分利用 Spring 依赖注入机制

### 2. 保持领域解耦
- Chat 域和 Workflow 域各自拥有独立的 ChatClient Bean
- 每个 ChatClient 配置了对应领域的 MessageChatMemoryAdvisor
- 领域边界清晰，职责单一

### 3. 代码简洁性
- 使用时只需设置 conversationId 参数
- 不再需要重复添加 advisor
- 代码更清晰，更易维护

### 4. 可扩展性
- 未来如果需要为不同领域添加其他 advisor（如 RAG），只需在 Bean 定义中配置
- 不影响业务代码

---

## 风险评估

### 技术风险

| 风险项 | 风险等级 | 缓解措施 |
|--------|----------|----------|
| Bean 循环依赖 | 🟢 低 | AiModelProvider 已存在，无新增依赖 |
| ChatClient 重复创建 | 🟢 低 | 使用单例 Bean，Spring 容器管理生命周期 |
| 性能影响 | 🟢 低 | ChatClient 创建在启动时，运行时无额外开销 |

### 业务风险

| 风险项 | 风险等级 | 缓解措施 |
|--------|----------|----------|
| 用户数据丢失 | 🟢 低 | 只改代码，不改数据库 |
| 功能回退 | 🟢 低 | 修改前后行为一致，只修复 bug |
| 兼容性问题 | 🟢 低 | 不改变接口签名，完全兼容 |

---

## 测试计划

### 单元测试（手动）

**测试用例 1**：Workflow 域多轮对话
```
1. 启动应用，验证 Bean 正常加载
2. 执行工作流，输入 "我叫小王"
3. 查看响应是否正常
4. 继续执行，输入 "我是谁"
5. 验证：响应应包含 "小王"
```

**测试用例 2**：Chat 域多轮对话
```
1. 调用 Chat API，消息 "我叫小王"
2. 使用相同 conversationId，消息 "我是谁"
3. 验证：响应应包含 "小王"
```

**测试用例 3**：无记忆模式
```
1. 执行工作流，不设置 conversationId
2. 验证：应使用无记忆模式（chatStream），不报错
```

**测试用例 4**：Bean 加载验证
```
1. 启动应用，检查日志
2. 验证：chatDomainChatClient 和 workflowDomainChatClient Bean 正常创建
3. 验证：无循环依赖警告
```

### 日志验证

**期望看到的日志**：
```
1. "查询工作流对话历史成功, 查询结果数: 2"
2. Encoding [ChatCompletionRequest[messages=[...包含历史消息...]
3. LLM 响应中包含 "小王"
```

---

## 实施计划

### 实施步骤

1. **修改配置类** (15 分钟)
   - 修改 `AiChatMemoryConfig.java`
   - 添加 2 个 ChatClient Bean 定义
   - 编译验证无错误

2. **修改服务类** (10 分钟)
   - 修改 `AiChatBaseService.java`
   - 注入领域专用 ChatClient
   - 更新 4 处方法调用
   - 编译验证无错误

3. **本地测试** (20 分钟)
   - 启动应用，验证 Bean 加载
   - 测试 Workflow 域多轮对话
   - 测试 Chat 域多轮对话（如果有测试数据）
   - 验证日志中历史消息注入

4. **代码审查** (10 分钟)
   - QA 评审代码质量
   - 验证符合 Spring AI 官方规范

5. **提交代码** (5 分钟)
   - Git commit with message
   - 保留方案文档

**总耗时**：约 60 分钟

### 验收标准

✅ **功能验收**：
- Workflow 域多轮对话记忆正常工作
- Chat 域多轮对话记忆正常工作
- 无记忆模式不受影响
- Bean 正常加载，无循环依赖

✅ **日志验收**：
- 日志显示历史消息查询成功
- 日志显示 LLM 请求包含历史消息
- Bean 创建日志正常

✅ **代码质量**：
- 符合 Spring AI 官方规范
- 保持 Chat 和 Workflow 解耦
- 符合 Spring 依赖注入最佳实践
- 通过 QA 代码评审

---

## 附录

### Spring AI AdvisorSpec 接口

```java
interface AdvisorSpec {
    AdvisorSpec param(String k, Object v);
    AdvisorSpec params(Map<String, Object> p);
    AdvisorSpec advisors(Advisor... advisors);
    AdvisorSpec advisors(List<Advisor> advisors);
}
```

### 参考文档

- **Spring AI 官方文档**：Chat Memory API
  https://github.com/spring-projects/spring-ai/blob/main/spring-ai-docs/src/main/antora/modules/ROOT/pages/api/advisors.adoc

- **Context7 文档**：MessageChatMemoryAdvisor 使用示例
  https://context7.com/spring-projects/spring-ai

- **项目设计文档**：`2025-01-07-AI工作流多轮对话上下文记忆-方案.md`

### 变更历史

| 日期 | 版本 | 变更说明 |
|------|------|----------|
| 2025-01-08 | v1.0 | 初始版本，定位问题并设计修复方案（基于推测） |
| 2025-01-08 | v2.0 | 重新设计，严格遵循 Spring AI 官方规范（Bean-based） |
