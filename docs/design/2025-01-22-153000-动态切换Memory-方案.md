# AI Chat调用Workflow时动态切换Memory - 方案设计

**日期**: 2025-01-22 15:30:00
**功能**: 选项2 - 动态切换Memory,解决AI Chat调用Workflow时上下文丢失

---

## 问题描述

**当前问题**: AI Chat调用Workflow时,LLM读取`ai_workflow_conversation_content`表(空表),导致对话上下文丢失

**期望行为**:
- AI Chat调用Workflow → 读取`ai_conversation_content`(Chat对话表)
- Workflow独立执行 → 读取`ai_workflow_conversation_content`(Workflow测试表)

---

## KISS原则7问

1. **这是个真问题还是臆想?** ✅ 真实问题,用户确认AI Chat调用Workflow时上下文丢失
2. **有更简单的方法吗?** ✅ 最简方案,1个if/else + 运行时advisor切换
3. **会破坏什么吗?** ✅ 零破坏,`callSource==WORKFLOW_TEST`保持原有行为
4. **当前项目真的需要?** ✅ 必要,否则AI Chat调用Workflow无法保持对话连贯性
5. **过度设计了吗?** ✅ 没有,所有Bean已存在,只需添加条件判断
6. **话题是否模糊?** ✅ 清晰,数据库查询机制已验证正常
7. **已学习代码实施注意事项?** ✅ 遵循第17条(查询使用SQL),无需新增Mapper

---

## 解决方案

### 修改文件

| 文件 | 修改内容 | 行数 |
|------|---------|------|
| `AiChatBaseService.java` | 在`chatWithWorkflowMemoryStream()`方法中根据`callSource`动态选择Memory Advisor | ~15行 |

### 核心代码

```java
// 文件: scm-ai/src/main/java/com/xinyirun/scm/ai/core/service/chat/AiChatBaseService.java
// 方法: chatWithWorkflowMemoryStream() 第199-263行

public ChatClient.StreamResponseSpec chatWithWorkflowMemoryStream(..., WorkflowCallSource callSource) {

    // 动态选择Memory Advisor
    MessageChatMemoryAdvisor selectedMemoryAdvisor;
    if (WorkflowCallSource.AI_CHAT.equals(callSource)) {
        selectedMemoryAdvisor = chatMessageChatMemoryAdvisor;  // Chat → ai_conversation_content
    } else {
        selectedMemoryAdvisor = workflowMessageChatMemoryAdvisor;  // Workflow → ai_workflow_conversation_content
    }

    // 有system分支
    if (StringUtils.isNotBlank(aiChatOption.getSystem())) {
        return workflowDomainChatClient.prompt()
            .system(aiChatOption.getSystem())
            .user(aiChatOption.getPrompt())
            .advisors(a -> {
                a.advisors(selectedMemoryAdvisor);  // 使用动态选择的Advisor
                a.param(ChatMemory.CONVERSATION_ID, aiChatOption.getConversationId());
                a.param(WorkflowConversationAdvisor.RUNTIME_UUID, runtimeUuid);
                if (StringUtils.isNotBlank(originalUserInput)) {
                    a.param(WorkflowConversationAdvisor.ORIGINAL_USER_INPUT, originalUserInput);
                }
                if (callSource != null) {
                    a.param(WorkflowConversationAdvisor.CALL_SOURCE, callSource.name());
                }
            })
            .stream();
    }

    // 无system分支 - 相同逻辑
    return workflowDomainChatClient.prompt()
        .user(aiChatOption.getPrompt())
        .advisors(a -> {
            a.advisors(selectedMemoryAdvisor);  // 使用动态选择的Advisor
            // ... 其他参数相同 ...
        })
        .stream();
}
```

### 关键变更点

1. **Bean已注入** (第49-52行):
   ```java
   @Resource
   MessageChatMemoryAdvisor chatMessageChatMemoryAdvisor;  // Chat Memory
   @Resource
   MessageChatMemoryAdvisor workflowMessageChatMemoryAdvisor;  // Workflow Memory
   ```

2. **动态选择逻辑**:
   - `callSource == AI_CHAT` → 使用`chatMessageChatMemoryAdvisor`
   - `callSource == WORKFLOW_TEST` → 使用`workflowMessageChatMemoryAdvisor`

3. **运行时切换**:
   - 在`advisors(a -> { a.advisors(selectedMemoryAdvisor); })`处动态注入

---

## 数据支撑

### 已验证的数据

1. **Bean配置** (`AiChatMemoryConfig.java`):
   - ✅ `chatMessageChatMemoryAdvisor` Bean已配置
   - ✅ `workflowMessageChatMemoryAdvisor` Bean已配置

2. **Memory实现**:
   - ✅ `ScmChatMessageChatMemory.get()` 查询`ai_conversation_content`
   - ✅ `ScmWorkflowMessageChatMemory.get()` 查询`ai_workflow_conversation_content`

3. **数据库查询** (`ExtAiConversationContentMapper.java`):
   - ✅ SQL使用`WHERE conversation_id = #{conversationId}`精确筛选
   - ✅ 索引`idx_ai_conversation_content_1`存在

4. **conversation_id格式**:
   - Chat: `"scm_tenant_20250519_001::6b2fcd7e-f7b7-4a75-9a7b-e92132c7874f"` (2段)
   - Workflow: `"tenantCode::workflowUuid::userId"` (3段)

5. **callSource参数**:
   - ✅ 方法签名已包含`WorkflowCallSource callSource`
   - ✅ `WorkflowConversationAdvisor`已使用此参数实现写入隔离

---

## 风险分析

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|---------|
| Advisor选择错误导致读错表 | 低 | 中 | 明确的if/else逻辑,日志记录选择结果 |
| callSource为null导致NPE | 低 | 低 | 已验证方法签名包含此参数,调用方传递 |
| 多线程并发安全 | 无 | 无 | Advisor是无状态Bean,线程安全 |

---

## 预期效果

**修复前**:
```
AI Chat调用Workflow:
  读取: ai_workflow_conversation_content (❌ 空表)
  结果: LLM无上下文
```

**修复后**:
```
AI Chat调用Workflow:
  读取: ai_conversation_content (✅ 正确上下文)
  结果: LLM有完整对话历史

Workflow独立执行:
  读取: ai_workflow_conversation_content (✅ 正确上下文)
  结果: 测试独立,不污染Chat数据
```

---

## 总结

**方案特点**:
- 简单: 15行代码
- 安全: 零破坏性
- 有效: 彻底解决上下文丢失问题
- 优雅: 利用现有架构,无新增概念

**数据结构正确,逻辑清晰,实用主义胜利。**
