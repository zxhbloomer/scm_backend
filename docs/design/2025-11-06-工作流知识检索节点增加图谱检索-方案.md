# 工作流知识检索节点增加图谱检索功能 - 设计方案

**日期**：2025-11-06
**作者**：AI开发团队
**状态**：待审批

---

## 一、问题诊断与需求分析

### 1.1 现状问题

**现象**：
- 工作流的知识检索节点（KnowledgeRetrievalNode）仅支持向量检索（Elasticsearch）
- 知识库对话功能（RagService）同时支持向量检索 + 图谱检索（Neo4j）
- 工作流节点无法利用知识图谱的实体和关系信息

**影响**：
- 工作流检索结果缺少结构化的知识图谱信息
- 无法利用实体关系进行推理和关联
- 与知识库对话功能的检索能力不一致

### 1.2 核心需求

在工作流知识检索节点中：
1. **增加图谱检索能力**：调用GraphRetrievalService获取实体和关系
2. **合并检索结果**：将向量结果和图谱结果合并为统一文本格式
3. **保持向后兼容**：默认行为不变，通过配置启用图谱检索
4. **结果传递**：合并后的文本能正确传递给下游LLM节点的`${input}`变量

### 1.3 用户场景

```
工作流示例：
[开始节点] → [知识检索节点(启用图谱)] → [LLM生成节点] → [结束节点]

知识检索节点输出：
【知识库上下文】

=== 向量检索结果 ===
[1] 供应链管理系统用于管理采购、库存和销售流程... (相似度: 0.85)
[2] 系统支持多租户架构，使用MySQL+Redis+MongoDB... (相似度: 0.73)

=== 图谱检索结果 ===
实体：SCM系统、采购模块、库存模块、MySQL数据库
关系：
  - SCM系统 [包含] 采购模块
  - SCM系统 [包含] 库存模块
  - SCM系统 [使用] MySQL数据库

【用户问题】
SCM系统的核心模块有哪些？
```

---

## 二、KISS原则评估

### 问题1：这是个真问题还是臆想出来的？

**✅ 真问题**

证据：
1. **用户明确需求**：用户主动提出要在工作流中支持图谱检索
2. **功能差异真实存在**：
   - RagService（对话功能）：向量 + 图谱
   - KnowledgeRetrievalNode（工作流）：仅向量
3. **数据库证据**：
   - `ai_knowledge_base_item.embedding_status` - 向量化状态
   - `ai_knowledge_base_item.graphical_status` - 图谱化状态
   - 两种索引都存在，但工作流只用了一种

### 问题2：有更简单的方法吗？

**✅ 已是最简方案**

分析：
1. **复用现有服务**：
   - VectorRetrievalService（已有）
   - GraphRetrievalService（已有）
   - 不需要新建检索服务

2. **复用合并逻辑**：
   - RagService.buildRagMessages()已实现向量+图谱合并
   - 直接复用相同的文本格式
   - 不需要发明新的数据结构

3. **状态检查自动化**：
   - Elasticsearch中的文档 = embedding_status=3的文档
   - Neo4j中的图谱 = graphical_status=3的文档
   - 检索服务通过数据存在性做隐式过滤，无需额外查询

4. **核心改动仅3处**：
   - KnowledgeRetrievalNodeConfig：增加配置字段
   - KnowledgeRetrievalNode：调用图谱服务并合并结果
   - 前端属性面板：增加开关控件

### 问题3：会破坏什么吗？

**✅ 零破坏性**

保证措施：
1. **配置默认值**：`enableGraphRetrieval = false`，默认行为不变
2. **检索服务无修改**：VectorRetrievalService、GraphRetrievalService保持不变
3. **输出格式兼容**：仍然返回纯文本字符串，LLM节点无需修改
4. **向后兼容**：现有工作流配置无此字段时，自动使用默认值（仅向量）

### 问题4：当前项目真的需要这个功能吗？

**✅ 必要性确认**

理由：
1. **知识图谱已投资**：
   - 系统已实现Neo4j图谱索引（DocumentIndexingService）
   - 系统已实现图谱检索（GraphRetrievalService）
   - 图谱数据已存在，但工作流无法使用

2. **功能一致性**：
   - 知识库对话功能已使用图谱检索
   - 工作流应提供同等的检索能力

3. **用户明确需求**：
   - 用户提供截图，展示知识库管理界面有"图谱化状态"列
   - 用户期望工作流能利用图谱数据

---

## 三、方案设计（按文件设计）

### 3.1 后端设计

#### 文件1：KnowledgeRetrievalNodeConfig.java

**路径**：`scm-ai/src/main/java/com/xinyirun/scm/ai/workflow/node/knowledgeretrieval/KnowledgeRetrievalNodeConfig.java`

**修改类型**：扩展配置类

**新增字段**：
```java
/**
 * 是否启用图谱检索
 * <p>默认false，仅使用向量检索，保持向后兼容</p>
 * <p>设置为true时，同时执行向量检索和图谱检索，合并结果</p>
 */
@JsonProperty("enable_graph_retrieval")
private Boolean enableGraphRetrieval;
```

**字段说明**：
- 类型：`Boolean`（可为null，null时视为false）
- JSON映射：`enable_graph_retrieval`（前端配置字段名）
- 默认行为：未配置时 = `false` = 仅向量检索
- 启用后：`true` = 向量 + 图谱双重检索

---

#### 文件2：KnowledgeRetrievalNode.java

**路径**：`scm-ai/src/main/java/com/xinyirun/scm/ai/workflow/node/knowledgeretrieval/KnowledgeRetrievalNode.java`

**修改类型**：增强节点处理逻辑

**核心改动**：

**1. 注入GraphRetrievalService**
```java
// 在onProcess()方法开始处获取服务实例
GraphRetrievalService graphRetrievalService = SpringUtil.getBean(GraphRetrievalService.class);
```

**2. 判断是否启用图谱检索**
```java
// 获取配置，默认false
boolean enableGraph = Boolean.TRUE.equals(nodeConfig.getEnableGraphRetrieval());
```

**3. 执行图谱检索**
```java
// 图谱检索结果（仅在启用时调用）
List<GraphSearchResultVo> graphResults = new ArrayList<>();

if (enableGraph) {
    log.info("图谱检索已启用，开始检索，kbUuid: {}", kbUuid);

    // 从kbUuid提取租户编码（格式：scm_tenant_20250519_001::uuid）
    String tenantCode = kbUuid.split("::", 2)[0];

    try {
        graphResults = graphRetrievalService.searchRelatedEntities(
            textInput, kbUuid, tenantCode, topN
        );
        log.info("图谱检索完成，结果数: {}", graphResults.size());
    } catch (Exception e) {
        log.error("图谱检索失败: {}", e.getMessage(), e);
        // 图谱检索失败不影响向量检索结果
    }
}
```

**4. 合并向量和图谱结果**
```java
StringBuilder resp = new StringBuilder();

// 向量检索结果
if (!searchResults.isEmpty()) {
    resp.append("=== 向量检索结果 ===\n");
    for (int i = 0; i < searchResults.size(); i++) {
        VectorSearchResultVo result = searchResults.get(i);
        resp.append("[").append(i + 1).append("] ")
            .append(result.getContent())
            .append(" (相似度: ").append(String.format("%.2f", result.getScore()))
            .append(")\n\n");
    }
}

// 图谱检索结果
if (!graphResults.isEmpty()) {
    resp.append("=== 图谱检索结果 ===\n");

    // 提取实体
    resp.append("实体：");
    String entities = graphResults.stream()
        .map(GraphSearchResultVo::getEntityName)
        .distinct()
        .collect(Collectors.joining("、"));
    resp.append(entities).append("\n");

    // 提取关系
    resp.append("关系：\n");
    for (GraphSearchResultVo result : graphResults) {
        if (result.getRelations() != null && !result.getRelations().isEmpty()) {
            for (GraphRelationVo relation : result.getRelations()) {
                resp.append("  - ")
                    .append(relation.getSourceEntityName())
                    .append(" [").append(relation.getRelationType()).append("] ")
                    .append(relation.getTargetEntityName())
                    .append("\n");
            }
        }
    }
    resp.append("\n");
}
```

**5. 处理空结果**
```java
// 检查检索结果
boolean vectorEmpty = searchResults == null || searchResults.isEmpty();
boolean graphEmpty = !enableGraph || graphResults.isEmpty();

if (vectorEmpty && graphEmpty) {
    log.warn("知识库检索结果为空，kbUuid: {}, 查询内容: {}", kbUuid, textInput);

    // 严格模式下检索结果为空时抛出异常
    if (isStrict) {
        throw new BusinessException("严格模式：知识库中未找到相关答案，请补充知识库内容或调整检索参数");
    }

    // 非严格模式下使用默认响应或返回空
    log.info("非严格模式：检索结果为空，返回默认响应");
}
```

**6. 需要导入的新类**
```java
import com.xinyirun.scm.ai.bean.vo.rag.GraphSearchResultVo;
import com.xinyirun.scm.ai.bean.vo.rag.GraphRelationVo;
import com.xinyirun.scm.ai.core.service.GraphRetrievalService;
import java.util.stream.Collectors;
```

**变更总结**：
- 新增代码行数：约60行
- 修改现有逻辑：最小化，仅在合并结果部分
- 复杂度：低（复用现有服务和格式）

---

### 3.2 前端设计

#### 文件3：KnowledgeRetrievalNodeProperty.vue

**路径**：`01_scm_frontend/scm_frontend/src/components/70_ai/components/workflow/components/properties/KnowledgeRetrievalNodeProperty.vue`

**修改类型**：增加配置项UI

**新增配置项**：

**位置**：在"严格模式"配置后面

**HTML模板**：
```vue
<!-- 图谱检索开关 -->
<div class="property-item">
  <div class="property-label">
    启用图谱检索
    <el-tooltip content="启用后将同时执行向量检索和图谱检索，合并实体和关系信息。需要知识库完成图谱化索引。" placement="top">
      <i class="el-icon-question"></i>
    </el-tooltip>
  </div>
  <el-switch
    v-model="nodeConfig.enable_graph_retrieval"
    active-text="启用"
    inactive-text="关闭"
  />
</div>
```

**初始化默认值**：
```javascript
// 在nodeConfig计算属性中添加默认值
if (this.wfNode.nodeConfig.enable_graph_retrieval === undefined) {
  this.$set(this.wfNode.nodeConfig, 'enable_graph_retrieval', false)
}
```

**说明文字**：
```vue
<div class="property-tips">
  <i class="el-icon-info"></i>
  <span>图谱检索需要知识库完成图谱化索引。检索结果将包含实体和关系信息，适合需要结构化知识的场景。</span>
</div>
```

**CSS样式**（如需要）：
```scss
.property-tips {
  margin-top: 8px;
  padding: 8px 12px;
  background: #f4f4f5;
  border-left: 3px solid #409eff;
  font-size: 12px;
  color: #606266;

  i {
    margin-right: 4px;
    color: #409eff;
  }
}
```

**变更总结**：
- 新增代码行数：约25行
- UI组件：el-switch（Element UI标准组件）
- 交互逻辑：简单开关，无复杂验证

---

### 3.3 数据流设计

```
用户输入（问题文本）
    ↓
KnowledgeRetrievalNode.onProcess()
    ↓
配置检查：enableGraphRetrieval?
    ↓
    ├─── false（默认）─────────────────────┐
    │                                     ↓
    │                            仅执行向量检索
    │                         VectorRetrievalService
    │                                     ↓
    │                            格式化向量结果
    │                                     ↓
    └─── true ─────────────────────────→ 合并
             ↓                           ↓
      并行执行两种检索              输出文本字符串
             ↓                           ↓
    VectorRetrievalService       NodeIOData.createByText()
    GraphRetrievalService              ↓
             ↓                    下游LLM节点接收
    合并向量和图谱结果            ${input}变量
             ↓
        格式化输出文本
```

---

## 四、支撑数据和分析

### 4.1 现有代码参考

**参考1：RagService的合并逻辑**
```java
// 位置：RagService.java:358-425
private List<Message> buildRagMessages(String question,
                                       List<VectorSearchResultVo> vectorResults,
                                       List<GraphSearchResultVo> graphResults,
                                       AiKnowledgeBaseVo knowledgeBase)
```

**验证点**：
- ✅ 已在生产环境验证
- ✅ 文本格式清晰，LLM能正确理解
- ✅ 向量和图谱结果独立可选

**参考2：GraphRetrievalService的调用**
```java
// 位置：RagService.java:180-181
List<GraphSearchResultVo> graphResults = graphRetrievalService.searchRelatedEntities(
    question, kbUuid, tenantCode, effectiveMaxResults);
```

**验证点**：
- ✅ 服务稳定，已在知识库对话中使用
- ✅ 参数简单：问题、知识库UUID、租户、结果数
- ✅ 异常处理完善

### 4.2 数据库结构验证

**表**：`ai_knowledge_base_item`

**关键字段**：
```sql
embedding_status   TINYINT  -- 向量化状态（1-待处理，2-处理中，3-已完成，4-失败）
graphical_status   TINYINT  -- 图谱化状态（1-待处理，2-处理中，3-已完成，4-失败）
```

**状态检查机制**：
```
embedding_status=3  →  Elasticsearch中有向量数据  →  向量检索有结果
graphical_status=3  →  Neo4j中有图谱数据        →  图谱检索有结果

未完成索引的文档   →  数据库中无对应记录        →  检索自动跳过
```

**结论**：无需额外状态查询，检索服务通过数据存在性做隐式过滤。

### 4.3 输出格式验证

**测试场景**：
```java
// 向量结果
VectorSearchResultVo v1 = new VectorSearchResultVo();
v1.setContent("SCM系统包含采购、库存、销售三大模块");
v1.setScore(0.85);

// 图谱结果
GraphSearchResultVo g1 = new GraphSearchResultVo();
g1.setEntityName("SCM系统");
GraphRelationVo r1 = new GraphRelationVo();
r1.setSourceEntityName("SCM系统");
r1.setRelationType("包含");
r1.setTargetEntityName("采购模块");
g1.setRelations(Arrays.asList(r1));

// 合并后输出
=== 向量检索结果 ===
[1] SCM系统包含采购、库存、销售三大模块 (相似度: 0.85)

=== 图谱检索结果 ===
实体：SCM系统
关系：
  - SCM系统 [包含] 采购模块
```

**传递验证**：
- ✅ 输出类型：`String`（纯文本）
- ✅ LLM节点接收：通过`${input}`变量
- ✅ 格式兼容：LLM能理解"=== XXX ==="分隔符

---

## 五、风险分析与缓解措施

### 5.1 技术风险

**风险1：图谱检索性能问题**

- **风险描述**：Neo4j查询可能比Elasticsearch慢
- **影响范围**：工作流执行时间增加
- **概率**：低（GraphRetrievalService已优化）
- **缓解措施**：
  1. 默认禁用图谱检索，用户按需启用
  2. 图谱检索失败不影响向量检索结果
  3. 日志记录性能指标，便于监控

**风险2：租户编码提取错误**

- **风险描述**：从kbUuid提取tenantCode可能失败
- **影响范围**：图谱检索调用失败
- **概率**：低（kbUuid格式固定：`tenantCode::uuid`）
- **缓解措施**：
  ```java
  String tenantCode;
  try {
      tenantCode = kbUuid.split("::", 2)[0];
  } catch (Exception e) {
      log.error("无法从kbUuid提取租户编码: {}", kbUuid);
      // 降级：不执行图谱检索
      graphResults = new ArrayList<>();
  }
  ```

**风险3：结果合并格式错误**

- **风险描述**：文本拼接逻辑错误，LLM无法理解
- **影响范围**：下游LLM节点生成质量下降
- **概率**：低（复用RagService已验证的格式）
- **缓解措施**：
  1. 单元测试验证输出格式
  2. 集成测试验证LLM节点能正确接收

### 5.2 业务风险

**风险4：知识库未完成图谱化**

- **风险描述**：用户启用图谱检索，但知识库无图谱数据
- **影响范围**：图谱检索返回空，可能不符合用户预期
- **概率**：中（用户可能误操作）
- **缓解措施**：
  1. 前端UI提示："图谱检索需要知识库完成图谱化索引"
  2. 图谱结果为空时，日志记录警告
  3. 非严格模式下，向量结果仍可用

**风险5：向后兼容性**

- **风险描述**：现有工作流加载时，新配置字段缺失
- **影响范围**：现有工作流行为变化
- **概率**：低（设计已保证兼容）
- **缓解措施**：
  1. 配置字段默认值：`enableGraphRetrieval = false`
  2. 后端代码：`Boolean.TRUE.equals(config.getEnableGraphRetrieval())`
  3. 前端初始化：检查undefined并设置默认值

### 5.3 风险等级评估

| 风险项 | 概率 | 影响 | 等级 | 优先级 |
|--------|------|------|------|--------|
| 图谱检索性能 | 低 | 中 | 低 | P3 |
| 租户编码提取 | 低 | 低 | 低 | P3 |
| 结果格式错误 | 低 | 高 | 中 | P2 |
| 知识库未图谱化 | 中 | 低 | 中 | P2 |
| 向后兼容性 | 低 | 高 | 中 | P1 |

**总体风险评级**：🟢 低风险

---

## 六、实施计划

### 6.1 开发阶段

**阶段1：后端核心逻辑**（预计1.5小时）
- 修改 `KnowledgeRetrievalNodeConfig.java`
- 修改 `KnowledgeRetrievalNode.java`
- 单元测试验证

**阶段2：前端配置界面**（预计0.5小时）
- 修改 `KnowledgeRetrievalNodeProperty.vue`
- UI交互测试

**阶段3：集成测试**（预计0.5小时）
- 创建测试工作流
- 验证向量+图谱检索
- 验证结果传递到LLM节点

**总计**：约2.5小时

### 6.2 测试策略

**单元测试**：
```java
@Test
public void testGraphRetrievalEnabled() {
    // 模拟配置启用图谱检索
    config.setEnableGraphRetrieval(true);

    // 执行节点
    NodeProcessResult result = node.onProcess();

    // 验证输出包含图谱结果标记
    String output = result.getContent().get(0).valueToString();
    assertTrue(output.contains("=== 图谱检索结果 ==="));
}

@Test
public void testGraphRetrievalDisabled() {
    // 配置禁用（默认）
    config.setEnableGraphRetrieval(false);

    // 执行节点
    NodeProcessResult result = node.onProcess();

    // 验证输出不包含图谱结果
    String output = result.getContent().get(0).valueToString();
    assertFalse(output.contains("=== 图谱检索结果 ==="));
}
```

**集成测试**：
1. 创建工作流：开始 → 知识检索（启用图谱） → LLM生成 → 结束
2. 运行工作流，检查LLM节点是否接收到图谱信息
3. 验证最终输出质量

### 6.3 部署注意事项

1. **数据库无变更**：无需执行SQL脚本
2. **缓存清理**：无需清理Redis缓存
3. **服务重启**：仅需重启scm-start服务
4. **前端部署**：需要重新构建前端资源

---

## 七、Linus式方案审查

### 【核心判断】
✅ **值得做**

**理由**：
1. 解决真实需求（知识图谱已投资，工作流应能使用）
2. 实现简单（复用现有服务，改动最小）
3. 零破坏性（向后兼容，默认行为不变）
4. 数据驱动（基于现有RagService的验证）

### 【关键洞察】

**数据结构**：
- 核心数据：文本字符串（向量结果 + 图谱结果拼接）
- 数据流向：检索服务 → 节点合并 → 下游LLM节点
- 无需修改数据结构，纯文本传递

**复杂度**：
- 消除的复杂性：不需要状态查询（检索服务隐式过滤）
- 新增复杂度：最小（仅1个配置字段 + 1次服务调用 + 文本拼接）
- 复杂度比：3行核心代码解决问题

**风险点**：
- 最大风险：向后兼容性（已通过默认值false解决）
- 次要风险：性能（已通过可选配置解决）
- 可控风险：图谱检索失败不影响向量结果

### 【Linus式方案】

**第一步：简化数据结构**
- ✅ 已是最简：纯文本拼接，无需新建数据对象

**第二步：消除所有特殊情况**
- ✅ 启用/禁用：统一用布尔配置控制
- ✅ 结果为空：统一用isEmpty()判断
- ✅ 异常处理：图谱失败降级为仅向量

**第三步：用最笨但最清晰的方式实现**
- ✅ 不用反射、不用动态代理
- ✅ 直接if-else判断、StringBuilder拼接
- ✅ 代码可读性 > 代码行数

**第四步：确保零破坏性**
- ✅ 配置默认值：false
- ✅ 检索服务不变
- ✅ 输出格式兼容
- ✅ 现有工作流行为不变

---

## 八、总结

### 方案优势

1. **简单**：核心改动仅60行代码，复用现有服务
2. **安全**：向后兼容，零破坏性
3. **实用**：解决真实需求，数据驱动
4. **可维护**：逻辑清晰，无特殊情况

### 预期效果

1. **功能完整性**：工作流检索能力与知识库对话一致
2. **灵活性**：用户可按需启用图谱检索
3. **质量提升**：LLM能利用结构化知识（实体+关系）

### 后续优化建议

1. **性能监控**：记录图谱检索耗时，优化慢查询
2. **用户引导**：提供示例工作流，演示图谱检索效果
3. **统计分析**：收集用户启用率，评估功能价值

---

**审批决策**：
- [ ] 批准实施
- [ ] 需要修改
- [ ] 暂停审批

**审批意见**：
```
（待填写）
```

**审批人**：________________
**审批日期**：________________
