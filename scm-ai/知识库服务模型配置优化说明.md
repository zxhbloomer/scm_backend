# 知识库服务模型配置优化说明

## 问题分析

### 旧设计的问题

在 `KnowledgeBaseService.java` 中，原来使用了已废弃的 `AiModelSourceEntity`:

```java
// ❌ 旧逻辑 (第98-112行)
LambdaQueryWrapper<AiModelSourceEntity> modelWrapper = new LambdaQueryWrapper<>();
modelWrapper.eq(AiModelSourceEntity::getId, vo.getIngestModelId());
AiModelSourceEntity modelEntity = aiModelSourceMapper.selectOne(modelWrapper);

if (modelEntity != null) {
    entity.setIngestModelId(vo.getIngestModelId());
    String normalizedModelName = normalizeModelNameForKb(modelEntity);
    entity.setIngestModelName(normalizedModelName);
}
```

**核心矛盾**:
- ❌ 旧逻辑: 知识库 → `AiModelSourceEntity` (已废弃的模型源表)
- ✅ 新逻辑: 知识库 → `AiModelConfigEntity` (新的统一模型配置表)

### 业务需求

知识库需要使用**嵌入模型(Embedding Model)**进行文档向量化:
- 文档上传 → 文本分块 → 嵌入模型转换为向量 → 存储到Elasticsearch
- 检索时: 用户问题 → 嵌入模型转换为向量 → Elasticsearch相似度搜索

## 优化方案

### 1. 依赖注入新服务

```java
// 新增依赖
private final AiModelConfigService aiModelConfigService;
```

### 2. 重构 `saveOrUpdate` 方法

使用新的模型配置服务替代旧逻辑:

```java
// ✅ 新逻辑：使用 AiModelConfigService
AiModelConfigVo modelConfig;

if (StringUtils.isNotBlank(vo.getIngestModelId())) {
    // 前端指定了模型ID，验证并使用该模型
    Long modelId = Long.parseLong(vo.getIngestModelId());
    modelConfig = aiModelConfigService.getModelConfigVo(modelId, null);

    // 验证模型类型必须是 EMBEDDING
    if (!"EMBEDDING".equalsIgnoreCase(modelConfig.getModelType())) {
        throw new RuntimeException("知识库只能使用嵌入模型");
    }

    // 验证模型是否启用
    if (!modelConfig.getEnabled()) {
        throw new RuntimeException("模型未启用");
    }

    entity.setIngestModelId(vo.getIngestModelId());
    entity.setIngestModelName(modelConfig.getModelName());

} else {
    // 未指定模型，使用系统默认嵌入模型
    modelConfig = aiModelConfigService.getDefaultModelConfig("EMBEDDING");

    entity.setIngestModelId(String.valueOf(modelConfig.getId()));
    entity.setIngestModelName(modelConfig.getModelName());
}
```

### 3. 删除旧的辅助方法

删除了不再需要的方法:
- `normalizeModelNameForKb(AiModelSourceEntity modelEntity)` (第165-185行)
- `isKnownModelNameForKb(String name)` (第193-207行)

这些方法是为了处理旧的 `AiModelSourceEntity` 命名不规范问题，新的 `AiModelConfigEntity` 已经规范化了模型名称。

## 优势对比

| 对比项 | 旧设计 | 新设计 |
|--------|--------|--------|
| **数据源** | `AiModelSourceEntity` (已废弃) | `AiModelConfigEntity` (新统一表) |
| **模型类型验证** | ❌ 无验证 | ✅ 必须是 EMBEDDING 类型 |
| **模型状态验证** | ❌ 无验证 | ✅ 必须是启用状态 |
| **默认模型** | ⚠️ 手动警告 | ✅ 自动获取系统默认嵌入模型 |
| **模型名称** | ⚠️ 需要复杂规范化逻辑 | ✅ 直接使用配置表的名称 |
| **代码复杂度** | 高 (3个方法，60+行) | 低 (1个方法，简洁明了) |
| **可维护性** | 差 (依赖废弃表) | 好 (使用新统一架构) |

## 业务流程

### 新增知识库流程

1. **前端传入模型ID** (可选)
   - 用户选择指定嵌入模型 → 后端验证类型和状态 → 保存

2. **前端未传入模型ID**
   - 后端从 `ai_config` 表获取 `DEFAULT_EMBEDDING_MODEL_ID`
   - 从 `ai_model_config` 表获取该模型配置
   - 验证类型和状态 → 保存

### 模型验证规则

```java
// 1. 模型类型必须是 EMBEDDING
if (!"EMBEDDING".equalsIgnoreCase(modelConfig.getModelType())) {
    throw new RuntimeException("知识库只能使用嵌入模型，当前模型类型为: " + modelConfig.getModelType());
}

// 2. 模型必须启用
if (!modelConfig.getEnabled()) {
    throw new RuntimeException("模型未启用: " + modelConfig.getModelName());
}
```

## 数据库架构

### 新的模型配置表结构

```sql
-- ai_model_config 表 (新统一模型配置表)
CREATE TABLE ai_model_config (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    model_name VARCHAR(255),           -- 模型名称 (如: text-embedding-3-large)
    model_type VARCHAR(50),             -- 模型类型 (LLM/VISION/EMBEDDING)
    provider VARCHAR(50),               -- 提供商 (OpenAI/Claude/SiliconFlow等)
    deployment_name VARCHAR(255),       -- 部署名称
    api_key VARCHAR(255),               -- API密钥
    base_url VARCHAR(255),              -- API基础URL
    enabled BOOLEAN,                    -- 是否启用
    support_embedding BOOLEAN,          -- 是否支持嵌入
    ...
);

-- ai_config 表 (全局配置表)
-- 存储默认模型ID配置
INSERT INTO ai_config (config_key, config_value) VALUES
('DEFAULT_LLM_MODEL_ID', '1'),
('DEFAULT_VISION_MODEL_ID', '2'),
('DEFAULT_EMBEDDING_MODEL_ID', '3');  -- 知识库使用的默认嵌入模型
```

### 知识库表结构

```sql
-- ai_knowledge_base 表
CREATE TABLE ai_knowledge_base (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    kb_uuid VARCHAR(255),
    title VARCHAR(255),
    ingest_model_id VARCHAR(50),        -- 嵌入模型ID (对应 ai_model_config.id)
    ingest_model_name VARCHAR(255),     -- 嵌入模型名称 (冗余字段，便于查询)
    ingest_token_estimator VARCHAR(50), -- Token估计器
    ...
);
```

## 使用示例

### 前端调用示例

```javascript
// 1. 新增知识库 - 使用指定嵌入模型
const createKbRequest = {
    title: "技术文档库",
    ingestModelId: "3",  // 指定嵌入模型ID
    ingestTokenEstimator: "cl100k_base"
};

// 2. 新增知识库 - 使用系统默认嵌入模型
const createKbRequest = {
    title: "技术文档库",
    // ingestModelId 不传，后端自动使用默认嵌入模型
    ingestTokenEstimator: "cl100k_base"
};
```

### 后端日志示例

```log
# 使用指定嵌入模型
知识库保存：使用指定嵌入模型，modelId: 3, modelName: text-embedding-3-large

# 使用默认嵌入模型
知识库保存：使用系统默认嵌入模型，modelId: 3, modelName: text-embedding-3-large

# 新增成功
新增知识库成功，kbUuid: tenant001::abc123, title: 技术文档库, ingestModelId: 3, ingestModelName: text-embedding-3-large
```

## 后续扩展建议

### 1. 支持多种嵌入模型切换

知识库可以支持更换嵌入模型，但需要注意:
- 更换模型后，需要重新索引所有文档
- 不同嵌入模型的向量维度可能不同，需要重建Elasticsearch索引

### 2. 模型能力验证

可以增加更精细的模型能力验证:

```java
// 验证嵌入模型能力
if (!modelConfig.getSupportEmbedding()) {
    throw new RuntimeException("该模型不支持嵌入功能");
}
```

### 3. 模型性能监控

记录嵌入模型的性能指标:
- 文档处理速度
- Token消耗量
- API调用成功率

## 兼容性说明

### 数据迁移

如果数据库中已经有使用旧 `AiModelSourceEntity` 创建的知识库:

```sql
-- 数据迁移脚本 (如果需要)
UPDATE ai_knowledge_base kb
SET
    ingest_model_id = (
        SELECT id FROM ai_model_config mc
        WHERE mc.model_name = kb.ingest_model_name
        AND mc.model_type = 'EMBEDDING'
        LIMIT 1
    )
WHERE ingest_model_id IN (
    SELECT id FROM ai_model_source  -- 旧表
);
```

## 总结

✅ **优化完成**:
- 使用新的 `AiModelConfigService` 替代旧的 `AiModelSourceEntity`
- 增加了嵌入模型类型验证和状态验证
- 支持系统默认嵌入模型自动配置
- 删除了不必要的模型名称规范化逻辑
- 代码更简洁、更易维护

✅ **业务逻辑更清晰**:
- 知识库明确只能使用 EMBEDDING 类型模型
- 支持用户指定模型或使用系统默认模型
- 自动验证模型有效性和启用状态

✅ **架构更统一**:
- 与整个AI模型配置体系保持一致
- 使用统一的模型配置管理服务
- 便于后续功能扩展和维护
