package com.xinyirun.scm.ai.service;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.xinyirun.scm.ai.bean.entity.chat.AiConversationEntity;
import com.xinyirun.scm.ai.bean.entity.chat.AiConversationContentEntity;
import com.xinyirun.scm.ai.bean.vo.chat.AiConversationVo;
import com.xinyirun.scm.ai.bean.vo.chat.AiConversationContentVo;
import com.xinyirun.scm.ai.bean.vo.request.AIChatRequestVo;
import com.xinyirun.scm.ai.bean.vo.request.AIConversationUpdateRequestVo;
import com.xinyirun.scm.ai.mapper.chat.AiConversationMapper;
import com.xinyirun.scm.ai.mapper.chat.AiConversationContentMapper;
import com.xinyirun.scm.ai.adapter.AiStreamHandler;
import com.xinyirun.scm.ai.service.AiConversationContentService;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

/**
 * AI对话服务
 *
 * 提供AI对话会话管理功能，包括对话的创建、查询、更新等操作
 *
 * @author SCM-AI重构团队
 * @since 2025-09-28
 */
@Service
@Transactional(propagation = Propagation.NOT_SUPPORTED)
@Slf4j
public class AiConversationService {

    @Resource
    private AiConversationMapper aiConversationMapper;

    @Resource
    private AiConversationContentMapper aiConversationContentMapper;

    @Resource
    private AiConversationContentService aiConversationContentService;

    /**
     * 根据ID查询对话
     *
     * @param id 对话ID
     * @return 对话VO
     */
    public AiConversationVo getById(String id) {
        try {
            AiConversationEntity entity = aiConversationMapper.selectById(id);
            if (entity != null) {
                return convertToVo(entity);
            }
            return null;
        } catch (Exception e) {
            log.error("根据ID查询对话失败, id: {}", id, e);
            return null;
        }
    }

    /**
     * 根据用户查询对话列表
     *
     * @param createUser 创建用户
     * @param tenant 租户标识
     * @param pageNum 页码
     * @param pageSize 页大小
     * @return 对话分页列表
     */
    public IPage<AiConversationVo> getByUser(String createUser, String tenant, int pageNum, int pageSize) {
        try {
            Page<AiConversationEntity> page = new Page<>(pageNum, pageSize);
            QueryWrapper<AiConversationEntity> wrapper = new QueryWrapper<>();

            wrapper.eq("create_user", createUser);
            if (StringUtils.hasText(tenant)) {
                wrapper.eq("tenant", tenant);
            }
            wrapper.orderByDesc("last_active_time");

            IPage<AiConversationEntity> entityPage = aiConversationMapper.selectPage(page, wrapper);

            // 转换为VO分页
            Page<AiConversationVo> voPage = new Page<>(pageNum, pageSize);
            voPage.setTotal(entityPage.getTotal());
            voPage.setRecords(entityPage.getRecords().stream()
                    .map(this::convertToVo)
                    .collect(Collectors.toList()));

            return voPage;
        } catch (Exception e) {
            log.error("根据用户查询对话列表失败, createUser: {}, tenant: {}", createUser, tenant, e);
            return new Page<>(pageNum, pageSize);
        }
    }

    /**
     * 更新对话信息
     *
     * @param conversationVo 对话VO
     * @param operatorId 操作员ID
     * @return 更新结果
     */
    @Transactional(rollbackFor = Exception.class)
    public boolean updateConversation(AiConversationVo conversationVo, Long operatorId) {
        try {
            AiConversationEntity entity = convertToEntity(conversationVo);

            LocalDateTime now = LocalDateTime.now();
            entity.setU_time(now);
            entity.setU_id(operatorId);

            int result = aiConversationMapper.updateById(entity);
            if (result > 0) {
                log.info("更新对话成功, id: {}", entity.getId());
                return true;
            }

            return false;
        } catch (Exception e) {
            log.error("更新对话失败", e);
            throw new RuntimeException("更新对话失败", e);
        }
    }

    /**
     * 结束对话
     *
     * @param conversationId 对话ID
     * @param operatorId 操作员ID
     * @return 结束结果
     */
    @Transactional(rollbackFor = Exception.class)
    public boolean endConversation(String conversationId, Long operatorId) {
        try {
            AiConversationEntity entity = new AiConversationEntity();
            entity.setId(conversationId);
            entity.setConversation_status(2); // 已结束
            entity.setU_time(LocalDateTime.now());
            entity.setU_id(operatorId);

            int result = aiConversationMapper.updateById(entity);
            if (result > 0) {
                log.info("结束对话成功, conversationId: {}", conversationId);
                return true;
            }

            return false;
        } catch (Exception e) {
            log.error("结束对话失败, conversationId: {}", conversationId, e);
            throw new RuntimeException("结束对话失败", e);
        }
    }

    /**
     * 删除对话（逻辑删除）
     *
     * @param conversationId 对话ID
     * @param operatorId 操作员ID
     * @return 删除结果
     */
    @Transactional(rollbackFor = Exception.class)
    public boolean deleteConversation(String conversationId, Long operatorId) {
        try {
            AiConversationEntity entity = new AiConversationEntity();
            entity.setId(conversationId);
            entity.setConversation_status(3); // 已删除
            entity.setU_time(LocalDateTime.now());
            entity.setU_id(operatorId);

            int result = aiConversationMapper.updateById(entity);
            if (result > 0) {
                log.info("删除对话成功, conversationId: {}", conversationId);
                return true;
            }

            return false;
        } catch (Exception e) {
            log.error("删除对话失败, conversationId: {}", conversationId, e);
            throw new RuntimeException("删除对话失败", e);
        }
    }

    /**
     * 为用户创建AI会话记录（由事件触发）
     *
     * @param convUuid 会话UUID
     * @param userId 用户ID
     * @param userName 用户名
     * @param tenant 租户标识
     */
    @Transactional(rollbackFor = Exception.class)
    public void createConversationForUser(String convUuid, Long userId, String userName, String tenant) {
        try {
            // 检查会话是否已存在
            QueryWrapper<AiConversationEntity> checkWrapper = new QueryWrapper<>();
            checkWrapper.eq("conv_uuid", convUuid);
            AiConversationEntity existingConversation = aiConversationMapper.selectOne(checkWrapper);
            if (existingConversation != null) {
                log.info("AI会话记录已存在，跳过创建：convUuid={}", convUuid);
                return;
            }

            // 创建AI会话记录
            AiConversationEntity entity = new AiConversationEntity();
            entity.setTitle("新对话"); // 设置默认标题
            entity.setCreate_user(String.valueOf(userId));
            entity.setTenant(tenant);

            LocalDateTime now = LocalDateTime.now();

            int result = aiConversationMapper.insert(entity);
            if (result > 0) {
                log.info("在chat-ai数据库中创建AI会话记录成功 - convUuid={}, userId={}, userName={}",
                        convUuid, userId, userName);
            } else {
                log.error("创建AI会话记录失败：插入数据库返回0 - convUuid={}, userId={}", convUuid, userId);
            }
        } catch (Exception e) {
            log.error("创建AI会话记录失败：userId={}, convUuid={}", userId, convUuid, e);
            throw e; // 重新抛出异常，让调用方处理
        }
    }

    /**
     * 创建新对话 - 供Controller使用
     *
     * @param conversationVo 对话VO
     * @param operatorId 操作员ID
     * @return 创建的对话VO
     */
    @Transactional(rollbackFor = Exception.class)
    public AiConversationVo createConversation(AiConversationVo conversationVo, Long operatorId) {
        try {
            AiConversationEntity entity = convertToEntity(conversationVo);

            LocalDateTime now = LocalDateTime.now();

            int result = aiConversationMapper.insert(entity);
            if (result > 0) {
                log.info("创建对话成功, title: {}", entity.getTitle());
                return convertToVo(entity);
            }

            return null;
        } catch (Exception e) {
            log.error("创建对话失败", e);
            throw new RuntimeException("创建对话失败", e);
        }
    }

    /**
     * 添加新对话 - 根据备份版本的add方法
     *
     * @param request 聊天请求
     * @param userId 用户ID
     * @return 对话实体
     */
    @Transactional(rollbackFor = Exception.class)
    public AiConversationVo add(AIChatRequestVo request, String userId) {
        try {
            String conversationTitle = request.getPrompt();
            if (conversationTitle.length() > 255) {
                conversationTitle = conversationTitle.substring(0, 255);
            }

            AiConversationEntity entity = new AiConversationEntity();
            entity.setId(request.getConversationId());
            entity.setTitle(conversationTitle);
            entity.setCreate_user(userId);
            entity.setCreate_time(System.currentTimeMillis());
            entity.setTenant(request.getTenantId());

            aiConversationMapper.insert(entity);
            return convertToVo(entity);
        } catch (Exception e) {
            log.error("添加对话失败", e);
            throw new RuntimeException("添加对话失败", e);
        }
    }

    /**
     * 删除对话及其内容 - 根据备份版本的delete方法
     *
     * @param conversationId 对话ID
     * @param userId 用户ID
     */
    @Transactional(rollbackFor = Exception.class)
    public void delete(String conversationId, String userId) {
        try {
            // 删除对话内容
            QueryWrapper<AiConversationContentEntity> contentWrapper = new QueryWrapper<>();
            contentWrapper.eq("conversation_id", conversationId);
            aiConversationContentMapper.delete(contentWrapper);

            // 删除对话记录
            aiConversationMapper.deleteById(conversationId);

            log.info("删除对话成功, conversationId: {}", conversationId);
        } catch (Exception e) {
            log.error("删除对话失败, conversationId: {}", conversationId, e);
            throw new RuntimeException("删除对话失败", e);
        }
    }

    /**
     * 清空对话内容（保留对话记录，只删除消息内容）
     *
     * @param conversationId 对话ID
     * @param userId 用户ID
     */
    @Transactional(rollbackFor = Exception.class)
    public void clearConversationContent(String conversationId, String userId) {
        try {
            QueryWrapper<AiConversationContentEntity> wrapper = new QueryWrapper<>();
            wrapper.eq("conversation_id", conversationId);
            int deletedCount = aiConversationContentMapper.delete(wrapper);

            log.info("对话内容已清空 - conversationId: {}, deletedCount: {}", conversationId, deletedCount);
        } catch (Exception e) {
            log.error("清空对话内容失败", e);
            throw new RuntimeException("清空对话内容失败：" + e.getMessage(), e);
        }
    }

    /**
     * 查询对话列表 - 根据备份版本的list方法
     *
     * @param userId 用户ID
     * @return 对话列表
     */
    public List<AiConversationVo> list(String userId) {
        try {
            QueryWrapper<AiConversationEntity> wrapper = new QueryWrapper<>();
            wrapper.eq("create_user", userId);
            wrapper.orderByDesc("last_active_time");

            List<AiConversationEntity> entities = aiConversationMapper.selectList(wrapper);
            return entities.stream()
                    .map(this::convertToVo)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            log.error("查询对话列表失败, userId: {}", userId, e);
            return List.of();
        }
    }

    /**
     * 根据conversationId获取对话信息 - 根据备份版本的getConversation方法
     *
     * @param conversationId 对话ID
     * @return 对话信息
     */
    public AiConversationVo getConversation(String conversationId) {
        try {
            AiConversationEntity entity = aiConversationMapper.selectById(conversationId);
            return entity != null ? convertToVo(entity) : null;
        } catch (Exception e) {
            log.error("获取对话信息失败, conversationId: {}", conversationId, e);
            return null;
        }
    }

    /**
     * 更新对话信息 - 根据备份版本的update方法
     *
     * @param request 更新请求
     * @param userId 用户ID
     * @return 更新后的对话信息
     */
    @Transactional(rollbackFor = Exception.class)
    public AiConversationVo update(AIConversationUpdateRequestVo request, String userId) {
        try {
            AiConversationEntity entity = new AiConversationEntity();
            entity.setId(request.getId());
            entity.setTitle(request.getTitle());

            aiConversationMapper.updateById(entity);
            return getConversation(request.getId());
        } catch (Exception e) {
            log.error("更新对话失败", e);
            throw new RuntimeException("更新对话失败", e);
        }
    }

    /**
     * 获取对话内容列表 - 根据备份版本的chatList方法
     *
     * @param conversationId 对话ID
     * @param userId 用户ID
     * @return 对话内容列表
     */
    public List<AiConversationContentVo> chatList(String conversationId, String userId) {
        try {
            QueryWrapper<AiConversationContentEntity> wrapper = new QueryWrapper<>();
            wrapper.eq("conversation_id", conversationId);
            wrapper.orderByAsc("c_time");

            List<AiConversationContentEntity> entities = aiConversationContentMapper.selectList(wrapper);
            return entities.stream()
                    .map(this::convertContentToVo)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            log.error("获取对话内容列表失败, conversationId: {}", conversationId, e);
            return List.of();
        }
    }

    /**
     * Entity转VO - 手动映射确保字段正确
     */
    private AiConversationVo convertToVo(AiConversationEntity entity) {
        AiConversationVo vo = new AiConversationVo();
        vo.setId(entity.getId());
        vo.setTitle(entity.getTitle());
        vo.setCreate_user(entity.getCreate_user());
        vo.setCreate_time(entity.getCreate_time());
        vo.setTenant(entity.getTenant());
        vo.setAi_config_id(entity.getAi_config_id());
        vo.setC_time(entity.getC_time());
        vo.setC_id(entity.getC_id());
        vo.setU_time(entity.getU_time());
        vo.setU_id(entity.getU_id());
        vo.setConv_uuid(entity.getConv_uuid());
        vo.setLast_active_time(entity.getLast_active_time());
        vo.setMessage_count(entity.getMessage_count());
        vo.setConversation_status(entity.getConversation_status());
        vo.setDbversion(entity.getDbversion());
        return vo;
    }

    /**
     * VO转Entity - 手动映射确保字段正确
     */
    private AiConversationEntity convertToEntity(AiConversationVo vo) {
        AiConversationEntity entity = new AiConversationEntity();
        entity.setId(vo.getId());
        entity.setTitle(vo.getTitle());
        entity.setCreate_user(vo.getCreate_user());
        entity.setCreate_time(vo.getCreate_time());
        return entity;
    }

    /**
     * 对话内容Entity转VO
     */
    private AiConversationContentVo convertContentToVo(AiConversationContentEntity entity) {
        AiConversationContentVo vo = new AiConversationContentVo();
        vo.setId(entity.getId());
        vo.setConversation_id(entity.getConversation_id());
        vo.setContent(entity.getContent());
        return vo;
    }

    /**
     * 保存用户对话内容
     *
     * @param conversationId 对话ID
     * @param content 用户输入内容
     * @param modelSourceId 模型来源ID
     */
    @Transactional(rollbackFor = Exception.class)
    public void saveUserConversationContent(String conversationId, String content, String modelSourceId) {
        try {
            AiConversationContentVo contentVo = new AiConversationContentVo();
            contentVo.setConversation_id(conversationId);
            contentVo.setRole("USER");
            contentVo.setContent(content);
            contentVo.setModel_source_id(modelSourceId);

            Long operatorId = getCurrentUserId();
            aiConversationContentService.addContent(contentVo, operatorId);

            log.debug("用户对话内容已保存: conversationId={}, modelSourceId={}", conversationId, modelSourceId);
        } catch (Exception e) {
            log.error("保存用户对话内容失败: conversationId={}, error={}", conversationId, e.getMessage(), e);
            throw new RuntimeException("保存用户对话内容失败", e);
        }
    }

    /**
     * 保存AI助手对话内容
     *
     * @param conversationId 对话ID
     * @param content AI回复内容
     * @param modelSourceId 模型来源ID
     */
    @Transactional(rollbackFor = Exception.class)
    public void saveAssistantConversationContent(String conversationId, String content, String modelSourceId) {
        try {
            AiConversationContentVo contentVo = new AiConversationContentVo();
            contentVo.setConversation_id(conversationId);
            contentVo.setContent(content);

            Long operatorId = getCurrentUserId();
            aiConversationContentService.addContent(contentVo, operatorId);

            log.debug("AI对话内容已保存: conversationId={}, modelSourceId={}", conversationId, modelSourceId);
        } catch (Exception e) {
            log.error("保存AI对话内容失败: conversationId={}, error={}", conversationId, e.getMessage(), e);
            throw new RuntimeException("保存AI对话内容失败", e);
        }
    }

    /**
     * 流式聊天 (WebSocket方式)
     *
     * @param request 聊天请求
     * @param userId 用户ID
     * @param sessionId WebSocket会话ID
     */
    public void chatStream(AIChatRequestVo request, String userId, String sessionId) {
        log.info("开始处理流式聊天请求: conversationId={}, userId={}, sessionId={}",
                request.getConversationId(), userId, sessionId);

        try {
            // 1. 保存用户输入内容
            saveUserConversationContent(request.getConversationId(), request.getPrompt(), request.getChatModelId());

            // 2. 创建WebSocket流式处理器
            AiStreamHandler.WebSocketStreamHandler streamHandler =
                    new AiStreamHandler.WebSocketStreamHandler(sessionId);

            // 3. 发送开始事件
            streamHandler.onStart();

            // 4. 模拟流式响应 (实际应该调用AI引擎)
            StringBuilder completeContent = new StringBuilder();
            String[] contentChunks = {"正在", "处理", "您的", "请求", "..."};

            for (String chunk : contentChunks) {
                streamHandler.onContent(chunk);
                completeContent.append(chunk);

                // 模拟处理延时
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }

            // 5. 保存完整回复内容
            String fullContent = completeContent.toString();
            saveAssistantConversationContent(request.getConversationId(), fullContent, request.getChatModelId());

            // 6. 发送完成事件
            streamHandler.onComplete(null);

            log.info("流式聊天处理完成: conversationId={}", request.getConversationId());

        } catch (Exception e) {
            log.error("流式聊天处理失败: conversationId={}, error={}",
                    request.getConversationId(), e.getMessage(), e);
            throw new RuntimeException("流式聊天处理失败", e);
        }
    }

    /**
     * 使用回调方式的流式聊天
     *
     * @param request 聊天请求
     * @param userId 用户ID
     * @param streamHandler 流式处理器
     */
    public void chatStreamWithCallback(AIChatRequestVo request, String userId, AiStreamHandler.CallbackStreamHandler streamHandler) {
        log.info("开始回调方式流式聊天: conversationId={}, userId={}", request.getConversationId(), userId);

        try {
            // 1. 保存用户输入内容
            saveUserConversationContent(request.getConversationId(), request.getPrompt(), request.getChatModelId());

            // 2. 发送开始事件
            streamHandler.onStreamStart();

            // 3. 模拟流式响应
            StringBuilder completeContent = new StringBuilder();
            String[] contentChunks = {"这是", "通过", "回调", "方式", "的", "流式", "响应"};

            for (String chunk : contentChunks) {
                streamHandler.onStreamContent(chunk);
                completeContent.append(chunk);

                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }

            // 4. 保存完整回复内容
            String fullContent = completeContent.toString();
            saveAssistantConversationContent(request.getConversationId(), fullContent, request.getChatModelId());

            // 5. 创建响应对象并发送完成事件
            // streamHandler.onStreamComplete(response); // 需要实际的AiResponse对象

            log.info("回调方式流式聊天完成: conversationId={}", request.getConversationId());

        } catch (Exception e) {
            log.error("回调方式流式聊天失败: conversationId={}, error={}",
                    request.getConversationId(), e.getMessage(), e);
            streamHandler.onStreamError(e);
        }
    }

}