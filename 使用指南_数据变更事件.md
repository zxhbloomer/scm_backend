# 数据变更事件系统使用指南

## 概述

基于Spring事务事件的数据变更优化设计，替代原有的MQ Consumer + Scheduler机制，解决循环依赖问题。

## 核心组件

### 1. 事件载体 - DataChangeEvent.java
```java
@Data
@Builder
public class DataChangeEvent {
    private String orderCode;      // 业务单号
    private String orderType;      // 单据类型
    private String tableName;      // 表名
    private String operation;      // INSERT/UPDATE/DELETE
    private Object beforeData;     // 变更前数据
    private Object afterData;      // 变更后数据
    private String requestId;      // 请求ID
    private String tenantCode;     // 租户代码
    private LocalDateTime eventTime; // 事件时间
}
```

### 2. 事件发布器 - DataChangePublisher.java
```java
// 静态工具类，无循环依赖
public class DataChangePublisher {
    public static void publish(String orderCode, String orderType, String tableName,
                              String operation, Object beforeData, Object afterData);
    
    public static void publishUpdate(String orderCode, String orderType, String tableName,
                                    Object beforeData, Object afterData);
    
    public static void publishInsert(String orderCode, String orderType, String tableName, Object data);
    
    public static void publishDelete(String orderCode, String orderType, String tableName, Object data);
}
```

### 3. 事务监听器 - DataChangeListener.java
```java
@Component
@Slf4j
public class DataChangeListener {
    @Autowired
    private IDataChangeProcessor processor;

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleDataChangeEvent(DataChangeEvent event) {
        // 事务提交后处理数据变更事件
    }
}
```

### 4. 处理接口 - IDataChangeProcessor.java
```java
public interface IDataChangeProcessor {
    void processDataChange(DataChangeEvent event);
}
```

### 5. MongoDB实现 - MongoDataChangeProcessor.java
```java
@Component
public class MongoDataChangeProcessor implements IDataChangeProcessor {
    @Override
    public void processDataChange(DataChangeEvent event) {
        // MongoDB数据变更日志处理逻辑
    }
}
```

## 业务代码集成示例

### 在Service层使用

```java
@Service
public class BusinessService {

    @Transactional
    public void updateOrder(OrderEntity order) {
        // 获取变更前数据
        OrderEntity beforeData = getById(order.getId());

        // 执行业务更新
        updateById(order);

        // 发布变更事件 - 静态方法调用，无循环依赖
        DataChangePublisher.publishUpdate(
            order.getOrderCode(),
            "PO",
            "b_po_order",
            beforeData,
            order
        );
    }

    @Transactional
    public void createOrder(OrderEntity order) {
        // 执行业务新增
        save(order);

        // 发布新增事件
        DataChangePublisher.publishInsert(
            order.getOrderCode(),
            "PO", 
            "b_po_order",
            order
        );
    }

    @Transactional
    public void deleteOrder(Long orderId) {
        // 获取删除前数据
        OrderEntity beforeData = getById(orderId);
        
        // 执行业务删除
        removeById(orderId);

        // 发布删除事件
        DataChangePublisher.publishDelete(
            beforeData.getOrderCode(),
            "PO",
            "b_po_order", 
            beforeData
        );
    }
}
```

## 优势

### ✅ 解决循环依赖
- DataChangePublisher改为静态工具类，去掉@Component注解
- 使用现有SpringContextUtil.getBean()方法获取ApplicationEventPublisher
- 业务服务直接调用静态方法，无需注入任何依赖

### ✅ 使用现有基础设施
- 复用SpringContextUtil
- 复用DataSourceHelper
- 不重复造轮子

### ✅ 业务代码调用简单
```java
// 原来的MQ方式（复杂）
@Autowired
private DataChangeProducer producer;
producer.sendMessage(dataChangeVo);

// 新的事件方式（简单）
DataChangePublisher.publishUpdate(orderCode, orderType, tableName, beforeData, afterData);
```

### ✅ 性能优化
- 替代MQ + Scheduler机制
- 直接在事务提交后处理
- 减少延迟和资源消耗

## 注意事项

1. **事务边界**: 确保在@Transactional方法中调用DataChangePublisher
2. **异常处理**: 事件处理异常不会影响主业务流程
3. **数据一致性**: 只有在事务成功提交后才会触发事件处理
4. **租户隔离**: 自动设置当前租户代码

## 迁移指南

### 替换原有MQ方式
```java
// 旧方式
@Autowired
private LogDataChangeProducer producer;
producer.mqSendMq(dataChangeVo);

// 新方式  
DataChangePublisher.publishUpdate(orderCode, orderType, tableName, beforeData, afterData);
```

### 移除相关依赖注入
```java
// 删除这些注入
// @Autowired
// private LogDataChangeProducer producer;
```

## 测试验证

1. 启动应用，观察Spring容器启动是否有循环依赖错误
2. 执行业务操作，查看日志确认事件发布和处理
3. 检查MongoDB中数据变更日志是否正常记录

## 故障排查

1. **事件未触发**: 检查是否在@Transactional方法中调用
2. **处理失败**: 查看MongoDataChangeProcessor的错误日志
3. **循环依赖**: 确认没有注入DataChangePublisher，只使用静态方法